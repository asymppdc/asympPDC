
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>boundedline</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-08-21"><meta name="DC.source" content="boundedline.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> varargout = boundedline(varargin)
<span class="comment">%BOUNDEDLINE Plot a line with shaded error/confidence bounds</span>
<span class="comment">%</span>
<span class="comment">% [hl, hp] = boundedline(x, y, b)</span>
<span class="comment">% [hl, hp] = boundedline(x, y, b, linespec)</span>
<span class="comment">% [hl, hp] = boundedline(x1, y1, b1, linespec1,  x2, y2, b2, linespec2)</span>
<span class="comment">% [hl, hp] = boundedline(..., 'alpha')</span>
<span class="comment">% [hl, hp] = boundedline(..., ax)</span>
<span class="comment">% [hl, hp] = boundedline(..., 'transparency', trans)</span>
<span class="comment">% [hl, hp] = boundedline(..., 'orientation', orient)</span>
<span class="comment">% [hl, hp] = boundedline(..., 'nan', nanflag)</span>
<span class="comment">% [hl, hp] = boundedline(..., 'cmap', cmap)</span>
<span class="comment">%</span>
<span class="comment">% Input variables:</span>
<span class="comment">%</span>
<span class="comment">%   x, y:       x and y values, either vectors of the same length, matrices</span>
<span class="comment">%               of the same size, or vector/matrix pair where the row or</span>
<span class="comment">%               column size of the array matches the length of the vector</span>
<span class="comment">%               (same requirements as for plot function).</span>
<span class="comment">%</span>
<span class="comment">%   b:          npoint x nside x nline array.  Distance from line to</span>
<span class="comment">%               boundary, for each point along the line (dimension 1), for</span>
<span class="comment">%               each side of the line (lower/upper or left/right, depending</span>
<span class="comment">%               on orientation) (dimension 2), and for each plotted line</span>
<span class="comment">%               described by the preceding x-y values (dimension 3).  If</span>
<span class="comment">%               size(b,1) == 1, the bounds will be the same for all points</span>
<span class="comment">%               along the line.  If size(b,2) == 1, the bounds will be</span>
<span class="comment">%               symmetrical on both sides of the lines.  If size(b,3) == 1,</span>
<span class="comment">%               the same bounds will be applied to all lines described by</span>
<span class="comment">%               the preceding x-y arrays (only applicable when either x or</span>
<span class="comment">%               y is an array).  Bounds cannot include Inf, -Inf, or NaN,</span>
<span class="comment">%</span>
<span class="comment">%   linespec:   line specification that determines line type, marker</span>
<span class="comment">%               symbol, and color of the plotted lines for the preceding</span>
<span class="comment">%               x-y values.</span>
<span class="comment">%</span>
<span class="comment">%   'alpha':    if included, the bounded area will be rendered with a</span>
<span class="comment">%               partially-transparent patch the same color as the</span>
<span class="comment">%               corresponding line(s).  If not included, the bounded area</span>
<span class="comment">%               will be an opaque patch with a lighter shade of the</span>
<span class="comment">%               corresponding line color.</span>
<span class="comment">%</span>
<span class="comment">%   ax:         handle of axis where lines will be plotted.  If not</span>
<span class="comment">%               included, the current axis will be used.</span>
<span class="comment">%</span>
<span class="comment">%   transp:     Scalar between 0 and 1 indicating with the transparency or</span>
<span class="comment">%               intensity of color of the bounded area patch. Default is</span>
<span class="comment">%               0.2.</span>
<span class="comment">%</span>
<span class="comment">%   orient:     direction to add bounds</span>
<span class="comment">%               'vert':   add bounds in vertical (y) direction (default)</span>
<span class="comment">%               'horiz':  add bounds in horizontal (x) direction</span>
<span class="comment">%</span>
<span class="comment">%   nanflag:    Sets how NaNs in the boundedline patch should be handled</span>
<span class="comment">%               'fill':   fill the value based on neighboring values,</span>
<span class="comment">%                         smoothing over the gap</span>
<span class="comment">%               'gap':    leave a blank space over/below the line</span>
<span class="comment">%               'remove': drop NaNs from patches, creating a linear</span>
<span class="comment">%                         interpolation over the gap.  Note that this</span>
<span class="comment">%                         applies only to the bounds; NaNs in the line will</span>
<span class="comment">%                         remain.</span>
<span class="comment">%</span>
<span class="comment">%   cmap:       n x 3 colormap array.  If included, lines will be colored</span>
<span class="comment">%               (in order of plotting) according to this colormap,</span>
<span class="comment">%               overriding any linespec or default colors.</span>
<span class="comment">%</span>
<span class="comment">% Output variables:</span>
<span class="comment">%</span>
<span class="comment">%   hl:         handles to line objects</span>
<span class="comment">%</span>
<span class="comment">%   hp:         handles to patch objects</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">%</span>
<span class="comment">% x = linspace(0, 2*pi, 50);</span>
<span class="comment">% y1 = sin(x);</span>
<span class="comment">% y2 = cos(x);</span>
<span class="comment">% e1 = rand(size(y1))*.5+.5;</span>
<span class="comment">% e2 = [.25 .5];</span>
<span class="comment">%</span>
<span class="comment">% ax(1) = subplot(2,2,1);</span>
<span class="comment">% [l,p] = boundedline(x, y1, e1, '-b*', x, y2, e2, '--ro');</span>
<span class="comment">% outlinebounds(l,p);</span>
<span class="comment">% title('Opaque bounds, with outline');</span>
<span class="comment">%</span>
<span class="comment">% ax(2) = subplot(2,2,2);</span>
<span class="comment">% boundedline(x, [y1;y2], rand(length(y1),2,2)*.5+.5, 'alpha');</span>
<span class="comment">% title('Transparent bounds');</span>
<span class="comment">%</span>
<span class="comment">% ax(3) = subplot(2,2,3);</span>
<span class="comment">% boundedline([y1;y2], x, e1(1), 'orientation', 'horiz')</span>
<span class="comment">% title('Horizontal bounds');</span>
<span class="comment">%</span>
<span class="comment">% ax(4) = subplot(2,2,4);</span>
<span class="comment">% boundedline(x, repmat(y1, 4,1), permute(0.5:-0.1:0.2, [3 1 2]), ...</span>
<span class="comment">%             'cmap', cool(4), 'transparency', 0.5);</span>
<span class="comment">% title('Multiple bounds using colormap');</span>


<span class="comment">% Copyright 2010 Kelly Kearney</span>

<span class="comment">%--------------------</span>
<span class="comment">% Parse input</span>
<span class="comment">%--------------------</span>

<span class="comment">% Color and cmap are mechanically the same:</span>

tmp = strncmpi(varargin,<span class="string">'color'</span>,3);
<span class="keyword">if</span> any(tmp)
   varargin{tmp} = <span class="string">'cmap'</span>;
<span class="keyword">end</span>

<span class="comment">% Alpha flag</span>

isalpha = cellfun(@(x) ischar(x) &amp;&amp; strcmp(x, <span class="string">'alpha'</span>), varargin);
<span class="keyword">if</span> any(isalpha)
    usealpha = true;
    varargin = varargin(~isalpha);
<span class="keyword">else</span>
    usealpha = false;
<span class="keyword">end</span>

<span class="comment">% Axis</span>

isax = cellfun(@(x) isscalar(x) &amp;&amp; ishandle(x) &amp;&amp; strcmp(<span class="string">'axes'</span>, get(x,<span class="string">'type'</span>)), varargin);
<span class="keyword">if</span> any(isax)
    hax = varargin{isax};
    varargin = varargin(~isax);
<span class="keyword">else</span>
    hax = gca;
<span class="keyword">end</span>

<span class="comment">% Transparency</span>

[found, trans, varargin] = parseparam(varargin, <span class="string">'transparency'</span>);

<span class="keyword">if</span> ~found
    trans = 0.2;
<span class="keyword">end</span>

<span class="keyword">if</span> ~isscalar(trans) || trans &lt; 0 || trans &gt; 1
    error(<span class="string">'Transparency must be scalar between 0 and 1'</span>);
<span class="keyword">end</span>

<span class="comment">% Orientation</span>

[found, orient, varargin] = parseparam(varargin, <span class="string">'orientation'</span>);

<span class="keyword">if</span> ~found
    orient = <span class="string">'vert'</span>;
<span class="keyword">end</span>

<span class="keyword">if</span> strcmp(orient, <span class="string">'vert'</span>)
    isvert = true;
<span class="keyword">elseif</span> strcmp(orient, <span class="string">'horiz'</span>)
    isvert = false;
<span class="keyword">else</span>
    error(<span class="string">'Orientation must be ''vert'' or ''horiz'''</span>);
<span class="keyword">end</span>

<span class="comment">% Colormap</span>

[hascmap, cmap, varargin] = parseparam(varargin, <span class="string">'cmap'</span>);

<span class="comment">% NaN flag</span>

[found, nanflag, varargin] = parseparam(varargin, <span class="string">'nan'</span>);
<span class="keyword">if</span> ~found
    nanflag = <span class="string">'fill'</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> ~ismember(nanflag, {<span class="string">'fill'</span>, <span class="string">'gap'</span>, <span class="string">'remove'</span>})
    error(<span class="string">'Nan flag must be ''fill'', ''gap'', or ''remove'''</span>);
<span class="keyword">end</span>

[haslw, lwidth, varargin] = parseparam(varargin, <span class="string">'linewidth'</span>);
<span class="keyword">if</span> ~haslw
    lwidth = get(0, <span class="string">'DefaultLineLineWidth'</span>);
<span class="keyword">end</span>

<span class="comment">% X, Y, E triplets, and linespec</span>

[x,y,err,linespec] = deal(cell(0));
<span class="keyword">while</span> ~isempty(varargin)
    <span class="keyword">if</span> length(varargin) &lt; 3
        error(<span class="string">'Unexpected input: should be x, y, bounds triplets'</span>);
    <span class="keyword">end</span>
    <span class="keyword">if</span> all(cellfun(@isnumeric, varargin(1:3)))
        x = [x varargin(1)];
        y = [y varargin(2)];
        err = [err varargin(3)];
        varargin(1:3) = [];
    <span class="keyword">else</span>
        <span class="keyword">if</span> any(cellfun(@(x) isa(x, <span class="string">'datetime'</span>), varargin(1:3)))
            <span class="comment">% Special error message for most likely culprit: datetimes</span>
            error(<span class="string">'boundedline cannot support datetime input due to incompatibility between patches and datetime axes; please convert to datenumbers instead'</span>);
        <span class="keyword">else</span>
            <span class="comment">% Otherwise</span>
            error(<span class="string">'Unexpected input: should be numeric x, y, bounds triplets'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(varargin) &amp;&amp; ischar(varargin{1})
        linespec = [linespec varargin(1)];
        varargin(1) = [];
    <span class="keyword">else</span>
        linespec = [linespec {[]}];
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%--------------------</span>
<span class="comment">% Reformat x and y</span>
<span class="comment">% for line and patch</span>
<span class="comment">% plotting</span>
<span class="comment">%--------------------</span>

<span class="comment">% Calculate y values for bounding lines</span>

plotdata = cell(0,7);

htemp = figure(<span class="string">'visible'</span>, <span class="string">'off'</span>);
<span class="keyword">for</span> ix = 1:length(x)

    <span class="comment">% Get full x, y, and linespec data for each line (easier to let plot</span>
    <span class="comment">% check for properly-sized x and y and expand values than to try to do</span>
    <span class="comment">% it myself)</span>

    <span class="keyword">try</span>
        <span class="keyword">if</span> isempty(linespec{ix})
            hltemp = plot(x{ix}, y{ix});
        <span class="keyword">else</span>
            hltemp = plot(x{ix}, y{ix}, linespec{ix});
        <span class="keyword">end</span>
    <span class="keyword">catch</span>
        close(htemp);
        error(<span class="string">'X and Y matrices and/or linespec not appropriate for line plot'</span>);
    <span class="keyword">end</span>

    linedata = get(hltemp, {<span class="string">'xdata'</span>, <span class="string">'ydata'</span>, <span class="string">'marker'</span>, <span class="string">'linestyle'</span>, <span class="string">'color'</span>});

    nline = size(linedata,1);

    <span class="comment">% Expand bounds matrix if necessary</span>

    <span class="keyword">if</span> nline &gt; 1
        <span class="keyword">if</span> ndims(err{ix}) == 3
            err2 = squeeze(num2cell(err{ix},[1 2]));
        <span class="keyword">else</span>
            err2 = repmat(err(ix),nline,1);
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        err2 = err(ix);
    <span class="keyword">end</span>

    <span class="comment">% Figure out upper and lower bounds</span>

    [lo, hi] = deal(cell(nline,1));
    <span class="keyword">for</span> iln = 1:nline

        x2 = linedata{iln,1};
        y2 = linedata{iln,2};
        nx = length(x2);

        <span class="keyword">if</span> isvert
            lineval = y2;
        <span class="keyword">else</span>
            lineval = x2;
        <span class="keyword">end</span>

        sz = size(err2{iln});

        <span class="keyword">if</span> isequal(sz, [nx 2])
            lo{iln} = lineval - err2{iln}(:,1)';
            hi{iln} = lineval + err2{iln}(:,2)';
        <span class="keyword">elseif</span> isequal(sz, [nx 1])
            lo{iln} = lineval - err2{iln}';
            hi{iln} = lineval + err2{iln}';
        <span class="keyword">elseif</span> isequal(sz, [1 2])
            lo{iln} = lineval - err2{iln}(1);
            hi{iln} = lineval + err2{iln}(2);
        <span class="keyword">elseif</span> isequal(sz, [1 1])
            lo{iln} = lineval - err2{iln};
            hi{iln} = lineval + err2{iln};
        <span class="keyword">elseif</span> isequal(sz, [2 nx]) <span class="comment">% not documented, but accepted anyways</span>
            lo{iln} = lineval - err2{iln}(:,1);
            hi{iln} = lineval + err2{iln}(:,2);
        <span class="keyword">elseif</span> isequal(sz, [1 nx]) <span class="comment">% not documented, but accepted anyways</span>
            lo{iln} = lineval - err2{iln};
            hi{iln} = lineval + err2{iln};
        <span class="keyword">elseif</span> isequal(sz, [2 1]) <span class="comment">% not documented, but accepted anyways</span>
            lo{iln} = lineval - err2{iln}(1);
            hi{iln} = lineval + err2{iln}(2);
        <span class="keyword">else</span>
            error(<span class="string">'Error bounds must be npt x nside x nline array'</span>);
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="comment">% Combine all data (xline, yline, marker, linestyle, color, lower bound</span>
    <span class="comment">% (x or y), upper bound (x or y)</span>

    plotdata = [plotdata; linedata lo hi];

<span class="keyword">end</span>
close(htemp);

<span class="comment">% Override colormap</span>

<span class="keyword">if</span> hascmap
    nd = size(plotdata,1);
    cmap = repmat(cmap, ceil(nd/size(cmap,1)), 1);
    cmap = cmap(1:nd,:);
    plotdata(:,5) = num2cell(cmap,2);
<span class="keyword">end</span>


<span class="comment">%--------------------</span>
<span class="comment">% Plot</span>
<span class="comment">%--------------------</span>

<span class="comment">% Setup of x and y, plus line and patch properties</span>

nline = size(plotdata,1);
[xl, yl, xp, yp, marker, lnsty, lncol, ptchcol, alpha] = deal(cell(nline,1));

<span class="keyword">for</span> iln = 1:nline
    xl{iln} = plotdata{iln,1};
    yl{iln} = plotdata{iln,2};
<span class="comment">%     if isvert</span>
<span class="comment">%         xp{iln} = [plotdata{iln,1} fliplr(plotdata{iln,1})];</span>
<span class="comment">%         yp{iln} = [plotdata{iln,6} fliplr(plotdata{iln,7})];</span>
<span class="comment">%     else</span>
<span class="comment">%         xp{iln} = [plotdata{iln,6} fliplr(plotdata{iln,7})];</span>
<span class="comment">%         yp{iln} = [plotdata{iln,2} fliplr(plotdata{iln,2})];</span>
<span class="comment">%     end</span>

    [xp{iln}, yp{iln}] = calcpatch(plotdata{iln,1}, plotdata{iln,2}, isvert, plotdata{iln,6}, plotdata{iln,7}, nanflag);

    marker{iln} = plotdata{iln,3};
    lnsty{iln} = plotdata{iln,4};

    <span class="keyword">if</span> usealpha
        lncol{iln} = plotdata{iln,5};
        ptchcol{iln} = plotdata{iln,5};
        alpha{iln} = trans;
    <span class="keyword">else</span>
        lncol{iln} = plotdata{iln,5};
        ptchcol{iln} = interp1([0 1], [1 1 1; lncol{iln}], trans);
        alpha{iln} = 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Plot patches and lines</span>

<span class="keyword">if</span> verLessThan(<span class="string">'matlab'</span>, <span class="string">'8.4.0'</span>)
    [hp,hl] = deal(zeros(nline,1));
<span class="keyword">else</span>
    [hp,hl] = deal(gobjects(nline,1));
<span class="keyword">end</span>


<span class="keyword">for</span> iln = 1:nline
    hp(iln) = patch(xp{iln}, yp{iln}, ptchcol{iln}, <span class="keyword">...</span>
        <span class="string">'facealpha'</span>, alpha{iln}, <span class="keyword">...</span>
        <span class="string">'edgecolor'</span>, <span class="string">'none'</span>, <span class="keyword">...</span>
        <span class="string">'parent'</span>, hax);
<span class="keyword">end</span>

<span class="keyword">for</span> iln = 1:nline
    hl(iln) = line(xl{iln}, yl{iln}, <span class="keyword">...</span>
        <span class="string">'marker'</span>, marker{iln}, <span class="keyword">...</span>
        <span class="string">'linestyle'</span>, lnsty{iln}, <span class="keyword">...</span>
        <span class="string">'color'</span>, lncol{iln}, <span class="keyword">...</span>
        <span class="string">'linewidth'</span>, lwidth, <span class="keyword">...</span>
        <span class="string">'parent'</span>, hax);
<span class="keyword">end</span>

<span class="comment">%--------------------</span>
<span class="comment">% Assign output</span>
<span class="comment">%--------------------</span>

nargoutchk(0,2);

<span class="keyword">if</span> nargout &gt;= 1
    varargout{1} = hl;
<span class="keyword">end</span>

<span class="keyword">if</span> nargout == 2
    varargout{2} = hp;
<span class="keyword">end</span>

<span class="comment">%--------------------</span>
<span class="comment">% Parse optional</span>
<span class="comment">% parameters</span>
<span class="comment">%--------------------</span>

<span class="keyword">function</span> [found, val, vars] = parseparam(vars, param)

isvar = cellfun(@(x) ischar(x) &amp;&amp; strcmpi(x, param), vars);

<span class="keyword">if</span> sum(isvar) &gt; 1
    error(<span class="string">'Parameters can only be passed once'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> any(isvar)
    found = true;
    idx = find(isvar);
    val = vars{idx+1};
    vars([idx idx+1]) = [];
<span class="keyword">else</span>
    found = false;
    val = [];
<span class="keyword">end</span>

<span class="comment">%----------------------------</span>
<span class="comment">% Calculate patch coordinates</span>
<span class="comment">%----------------------------</span>

<span class="keyword">function</span> [xp, yp] = calcpatch(xl, yl, isvert, lo, hi, nanflag)

ismissing = isnan([xl;yl;lo;hi]);

<span class="comment">% If gap method, split</span>

<span class="keyword">if</span> any(ismissing(:)) &amp;&amp; strcmp(nanflag, <span class="string">'gap'</span>)

    tmp = [xl;yl;lo;hi];

    idx = find(any(ismissing,1));
    n = diff([0 idx length(xl)]);

    tmp = mat2cell(tmp, 4, n);
    isemp = cellfun(<span class="string">'isempty'</span>, tmp);
    tmp = tmp(~isemp);

    tmp = cellfun(@(a) a(:,~any(isnan(a),1)), tmp, <span class="string">'uni'</span>, 0);
    isemp = cellfun(<span class="string">'isempty'</span>, tmp);
    tmp = tmp(~isemp);

    xl = cellfun(@(a) a(1,:), tmp, <span class="string">'uni'</span>, 0);
    yl = cellfun(@(a) a(2,:), tmp, <span class="string">'uni'</span>, 0);
    lo = cellfun(@(a) a(3,:), tmp, <span class="string">'uni'</span>, 0);
    hi = cellfun(@(a) a(4,:), tmp, <span class="string">'uni'</span>, 0);
<span class="keyword">else</span>
    xl = {xl};
    yl = {yl};
    lo = {lo};
    hi = {hi};
<span class="keyword">end</span>

[xp, yp] = deal(cell(size(xl)));

<span class="keyword">for</span> ii = 1:length(xl)

    iseq = ~verLessThan(<span class="string">'matlab'</span>, <span class="string">'8.4.0'</span>) &amp;&amp; isequal(lo{ii}, hi{ii}); <span class="comment">% deal with zero-width bug in R2014b/R2015a</span>

    <span class="keyword">if</span> isvert
        <span class="keyword">if</span> iseq
            xp{ii} = [xl{ii} nan(size(xl{ii}))];
            yp{ii} = [lo{ii} fliplr(hi{ii})];
        <span class="keyword">else</span>
            xp{ii} = [xl{ii} fliplr(xl{ii})];
            yp{ii} = [lo{ii} fliplr(hi{ii})];
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">if</span> iseq
            xp{ii} = [lo{ii} fliplr(hi{ii})];
            yp{ii} = [yl{ii} nan(size(yl{ii}))];
        <span class="keyword">else</span>
            xp{ii} = [lo{ii} fliplr(hi{ii})];
            yp{ii} = [yl{ii} fliplr(yl{ii})];
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> strcmp(nanflag, <span class="string">'fill'</span>)
        xp{ii} = inpaint_nans(xp{ii}', 4);
        yp{ii} = inpaint_nans(yp{ii}', 4);
        <span class="keyword">if</span> iseq <span class="comment">% need to maintain NaNs for zero-width bug</span>
            nx = length(xp{ii});
            xp{ii}((nx/2)+1:end) = NaN;
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> strcmp(nanflag, <span class="string">'remove'</span>)
        <span class="keyword">if</span> iseq
            nx = length(xp{ii});
            keepnan = false(size(xp));
            keepnan((nx/2)+1:end) = true;
            isn = (isnan(xp{ii}) | isnan(yp{ii})) &amp; ~keepnan;
        <span class="keyword">else</span>
            isn = isnan(xp{ii}) | isnan(yp{ii});
        <span class="keyword">end</span>
        xp{ii} = xp{ii}(~isn);
        yp{ii} = yp{ii}(~isn);
    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">if</span> strcmp(nanflag, <span class="string">'gap'</span>)
    [xp, yp] = singlepatch(xp, yp);
<span class="keyword">else</span>
    xp = xp{1};
    yp = yp{1};
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="boundedline_01.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = boundedline(varargin)
%BOUNDEDLINE Plot a line with shaded error/confidence bounds
%
% [hl, hp] = boundedline(x, y, b)
% [hl, hp] = boundedline(x, y, b, linespec)
% [hl, hp] = boundedline(x1, y1, b1, linespec1,  x2, y2, b2, linespec2)
% [hl, hp] = boundedline(..., 'alpha')
% [hl, hp] = boundedline(..., ax)
% [hl, hp] = boundedline(..., 'transparency', trans)
% [hl, hp] = boundedline(..., 'orientation', orient)
% [hl, hp] = boundedline(..., 'nan', nanflag)
% [hl, hp] = boundedline(..., 'cmap', cmap)
%
% Input variables:
%
%   x, y:       x and y values, either vectors of the same length, matrices
%               of the same size, or vector/matrix pair where the row or
%               column size of the array matches the length of the vector
%               (same requirements as for plot function).
%
%   b:          npoint x nside x nline array.  Distance from line to
%               boundary, for each point along the line (dimension 1), for
%               each side of the line (lower/upper or left/right, depending
%               on orientation) (dimension 2), and for each plotted line
%               described by the preceding x-y values (dimension 3).  If
%               size(b,1) == 1, the bounds will be the same for all points
%               along the line.  If size(b,2) == 1, the bounds will be
%               symmetrical on both sides of the lines.  If size(b,3) == 1,
%               the same bounds will be applied to all lines described by
%               the preceding x-y arrays (only applicable when either x or
%               y is an array).  Bounds cannot include Inf, -Inf, or NaN,
%
%   linespec:   line specification that determines line type, marker
%               symbol, and color of the plotted lines for the preceding
%               x-y values.
%
%   'alpha':    if included, the bounded area will be rendered with a
%               partially-transparent patch the same color as the
%               corresponding line(s).  If not included, the bounded area
%               will be an opaque patch with a lighter shade of the
%               corresponding line color.
%
%   ax:         handle of axis where lines will be plotted.  If not
%               included, the current axis will be used.
%
%   transp:     Scalar between 0 and 1 indicating with the transparency or
%               intensity of color of the bounded area patch. Default is
%               0.2.
%
%   orient:     direction to add bounds
%               'vert':   add bounds in vertical (y) direction (default)
%               'horiz':  add bounds in horizontal (x) direction 
%
%   nanflag:    Sets how NaNs in the boundedline patch should be handled
%               'fill':   fill the value based on neighboring values,
%                         smoothing over the gap
%               'gap':    leave a blank space over/below the line
%               'remove': drop NaNs from patches, creating a linear
%                         interpolation over the gap.  Note that this
%                         applies only to the bounds; NaNs in the line will
%                         remain.
%
%   cmap:       n x 3 colormap array.  If included, lines will be colored
%               (in order of plotting) according to this colormap,
%               overriding any linespec or default colors. 
%
% Output variables:
%
%   hl:         handles to line objects
%
%   hp:         handles to patch objects
%
% Example:
%
% x = linspace(0, 2*pi, 50);
% y1 = sin(x);
% y2 = cos(x);
% e1 = rand(size(y1))*.5+.5;
% e2 = [.25 .5];
% 
% ax(1) = subplot(2,2,1);
% [l,p] = boundedline(x, y1, e1, '-b*', x, y2, e2, 'REPLACE_WITH_DASH_DASHro');
% outlinebounds(l,p);
% title('Opaque bounds, with outline');
% 
% ax(2) = subplot(2,2,2);
% boundedline(x, [y1;y2], rand(length(y1),2,2)*.5+.5, 'alpha');
% title('Transparent bounds');
% 
% ax(3) = subplot(2,2,3);
% boundedline([y1;y2], x, e1(1), 'orientation', 'horiz')
% title('Horizontal bounds');
% 
% ax(4) = subplot(2,2,4);
% boundedline(x, repmat(y1, 4,1), permute(0.5:-0.1:0.2, [3 1 2]), ...
%             'cmap', cool(4), 'transparency', 0.5);
% title('Multiple bounds using colormap');


% Copyright 2010 Kelly Kearney

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Parse input
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

% Color and cmap are mechanically the same: 

tmp = strncmpi(varargin,'color',3); 
if any(tmp)
   varargin{tmp} = 'cmap'; 
end

% Alpha flag

isalpha = cellfun(@(x) ischar(x) && strcmp(x, 'alpha'), varargin);
if any(isalpha)
    usealpha = true;
    varargin = varargin(~isalpha);
else
    usealpha = false;
end

% Axis

isax = cellfun(@(x) isscalar(x) && ishandle(x) && strcmp('axes', get(x,'type')), varargin);
if any(isax)
    hax = varargin{isax};
    varargin = varargin(~isax);
else
    hax = gca;
end

% Transparency

[found, trans, varargin] = parseparam(varargin, 'transparency');

if ~found
    trans = 0.2;
end

if ~isscalar(trans) || trans < 0 || trans > 1
    error('Transparency must be scalar between 0 and 1');
end

% Orientation

[found, orient, varargin] = parseparam(varargin, 'orientation');

if ~found
    orient = 'vert';
end

if strcmp(orient, 'vert')
    isvert = true;
elseif strcmp(orient, 'horiz')
    isvert = false;
else
    error('Orientation must be ''vert'' or ''horiz''');
end

% Colormap

[hascmap, cmap, varargin] = parseparam(varargin, 'cmap');

% NaN flag

[found, nanflag, varargin] = parseparam(varargin, 'nan');
if ~found
    nanflag = 'fill';
end
if ~ismember(nanflag, {'fill', 'gap', 'remove'})
    error('Nan flag must be ''fill'', ''gap'', or ''remove''');
end

[haslw, lwidth, varargin] = parseparam(varargin, 'linewidth');
if ~haslw
    lwidth = get(0, 'DefaultLineLineWidth');
end

% X, Y, E triplets, and linespec

[x,y,err,linespec] = deal(cell(0));
while ~isempty(varargin)
    if length(varargin) < 3
        error('Unexpected input: should be x, y, bounds triplets');
    end
    if all(cellfun(@isnumeric, varargin(1:3)))
        x = [x varargin(1)];
        y = [y varargin(2)];
        err = [err varargin(3)];
        varargin(1:3) = [];
    else
        if any(cellfun(@(x) isa(x, 'datetime'), varargin(1:3)))
            % Special error message for most likely culprit: datetimes
            error('boundedline cannot support datetime input due to incompatibility between patches and datetime axes; please convert to datenumbers instead');
        else
            % Otherwise
            error('Unexpected input: should be numeric x, y, bounds triplets');
        end
    end
    if ~isempty(varargin) && ischar(varargin{1})
        linespec = [linespec varargin(1)];
        varargin(1) = [];
    else
        linespec = [linespec {[]}];
    end 
end    

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Reformat x and y
% for line and patch
% plotting
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

% Calculate y values for bounding lines

plotdata = cell(0,7);

htemp = figure('visible', 'off');
for ix = 1:length(x)
    
    % Get full x, y, and linespec data for each line (easier to let plot
    % check for properly-sized x and y and expand values than to try to do
    % it myself) 
    
    try
        if isempty(linespec{ix})
            hltemp = plot(x{ix}, y{ix});
        else
            hltemp = plot(x{ix}, y{ix}, linespec{ix});
        end
    catch
        close(htemp);
        error('X and Y matrices and/or linespec not appropriate for line plot');
    end
    
    linedata = get(hltemp, {'xdata', 'ydata', 'marker', 'linestyle', 'color'});
    
    nline = size(linedata,1);
    
    % Expand bounds matrix if necessary
    
    if nline > 1
        if ndims(err{ix}) == 3
            err2 = squeeze(num2cell(err{ix},[1 2]));
        else
            err2 = repmat(err(ix),nline,1);
        end
    else
        err2 = err(ix);
    end
    
    % Figure out upper and lower bounds
    
    [lo, hi] = deal(cell(nline,1));
    for iln = 1:nline
        
        x2 = linedata{iln,1};
        y2 = linedata{iln,2};
        nx = length(x2);
        
        if isvert
            lineval = y2;
        else
            lineval = x2;
        end
            
        sz = size(err2{iln});
        
        if isequal(sz, [nx 2])
            lo{iln} = lineval - err2{iln}(:,1)';
            hi{iln} = lineval + err2{iln}(:,2)';
        elseif isequal(sz, [nx 1])
            lo{iln} = lineval - err2{iln}';
            hi{iln} = lineval + err2{iln}';
        elseif isequal(sz, [1 2])
            lo{iln} = lineval - err2{iln}(1);
            hi{iln} = lineval + err2{iln}(2);
        elseif isequal(sz, [1 1])
            lo{iln} = lineval - err2{iln};
            hi{iln} = lineval + err2{iln};
        elseif isequal(sz, [2 nx]) % not documented, but accepted anyways
            lo{iln} = lineval - err2{iln}(:,1);
            hi{iln} = lineval + err2{iln}(:,2);
        elseif isequal(sz, [1 nx]) % not documented, but accepted anyways
            lo{iln} = lineval - err2{iln};
            hi{iln} = lineval + err2{iln};
        elseif isequal(sz, [2 1]) % not documented, but accepted anyways
            lo{iln} = lineval - err2{iln}(1);
            hi{iln} = lineval + err2{iln}(2);
        else
            error('Error bounds must be npt x nside x nline array');
        end 
            
    end
    
    % Combine all data (xline, yline, marker, linestyle, color, lower bound
    % (x or y), upper bound (x or y) 
    
    plotdata = [plotdata; linedata lo hi];
        
end
close(htemp);

% Override colormap

if hascmap
    nd = size(plotdata,1);
    cmap = repmat(cmap, ceil(nd/size(cmap,1)), 1);
    cmap = cmap(1:nd,:);
    plotdata(:,5) = num2cell(cmap,2);
end


%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Plot
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

% Setup of x and y, plus line and patch properties

nline = size(plotdata,1);
[xl, yl, xp, yp, marker, lnsty, lncol, ptchcol, alpha] = deal(cell(nline,1));

for iln = 1:nline
    xl{iln} = plotdata{iln,1};
    yl{iln} = plotdata{iln,2};
%     if isvert
%         xp{iln} = [plotdata{iln,1} fliplr(plotdata{iln,1})];
%         yp{iln} = [plotdata{iln,6} fliplr(plotdata{iln,7})];
%     else
%         xp{iln} = [plotdata{iln,6} fliplr(plotdata{iln,7})];
%         yp{iln} = [plotdata{iln,2} fliplr(plotdata{iln,2})];
%     end
    
    [xp{iln}, yp{iln}] = calcpatch(plotdata{iln,1}, plotdata{iln,2}, isvert, plotdata{iln,6}, plotdata{iln,7}, nanflag);
    
    marker{iln} = plotdata{iln,3};
    lnsty{iln} = plotdata{iln,4};
    
    if usealpha
        lncol{iln} = plotdata{iln,5};
        ptchcol{iln} = plotdata{iln,5};
        alpha{iln} = trans;
    else
        lncol{iln} = plotdata{iln,5};
        ptchcol{iln} = interp1([0 1], [1 1 1; lncol{iln}], trans);
        alpha{iln} = 1;
    end
end
    
% Plot patches and lines

if verLessThan('matlab', '8.4.0')
    [hp,hl] = deal(zeros(nline,1));
else
    [hp,hl] = deal(gobjects(nline,1));
end


for iln = 1:nline
    hp(iln) = patch(xp{iln}, yp{iln}, ptchcol{iln}, ...
        'facealpha', alpha{iln}, ...
        'edgecolor', 'none', ...
        'parent', hax);
end

for iln = 1:nline
    hl(iln) = line(xl{iln}, yl{iln}, ...
        'marker', marker{iln}, ...
        'linestyle', lnsty{iln}, ...
        'color', lncol{iln}, ...
        'linewidth', lwidth, ...
        'parent', hax);
end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Assign output
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

nargoutchk(0,2);

if nargout >= 1
    varargout{1} = hl;
end

if nargout == 2
    varargout{2} = hp;
end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Parse optional 
% parameters
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function [found, val, vars] = parseparam(vars, param)

isvar = cellfun(@(x) ischar(x) && strcmpi(x, param), vars);

if sum(isvar) > 1
    error('Parameters can only be passed once');
end

if any(isvar)
    found = true;
    idx = find(isvar);
    val = vars{idx+1};
    vars([idx idx+1]) = [];
else
    found = false;
    val = [];
end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Calculate patch coordinates
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function [xp, yp] = calcpatch(xl, yl, isvert, lo, hi, nanflag)

ismissing = isnan([xl;yl;lo;hi]);

% If gap method, split

if any(ismissing(:)) && strcmp(nanflag, 'gap')
    
    tmp = [xl;yl;lo;hi];
   
    idx = find(any(ismissing,1));
    n = diff([0 idx length(xl)]);
    
    tmp = mat2cell(tmp, 4, n);
    isemp = cellfun('isempty', tmp);
    tmp = tmp(~isemp);
    
    tmp = cellfun(@(a) a(:,~any(isnan(a),1)), tmp, 'uni', 0);
    isemp = cellfun('isempty', tmp);
    tmp = tmp(~isemp);
    
    xl = cellfun(@(a) a(1,:), tmp, 'uni', 0);
    yl = cellfun(@(a) a(2,:), tmp, 'uni', 0);
    lo = cellfun(@(a) a(3,:), tmp, 'uni', 0);
    hi = cellfun(@(a) a(4,:), tmp, 'uni', 0);
else
    xl = {xl};
    yl = {yl};
    lo = {lo};
    hi = {hi};
end

[xp, yp] = deal(cell(size(xl)));

for ii = 1:length(xl)

    iseq = ~verLessThan('matlab', '8.4.0') && isequal(lo{ii}, hi{ii}); % deal with zero-width bug in R2014b/R2015a

    if isvert
        if iseq
            xp{ii} = [xl{ii} nan(size(xl{ii}))];
            yp{ii} = [lo{ii} fliplr(hi{ii})];
        else
            xp{ii} = [xl{ii} fliplr(xl{ii})];
            yp{ii} = [lo{ii} fliplr(hi{ii})];
        end
    else
        if iseq
            xp{ii} = [lo{ii} fliplr(hi{ii})];
            yp{ii} = [yl{ii} nan(size(yl{ii}))];
        else
            xp{ii} = [lo{ii} fliplr(hi{ii})];
            yp{ii} = [yl{ii} fliplr(yl{ii})];
        end
    end
    
    if strcmp(nanflag, 'fill')
        xp{ii} = inpaint_nans(xp{ii}', 4);
        yp{ii} = inpaint_nans(yp{ii}', 4);
        if iseq % need to maintain NaNs for zero-width bug
            nx = length(xp{ii});
            xp{ii}((nx/2)+1:end) = NaN;
        end
    elseif strcmp(nanflag, 'remove')
        if iseq
            nx = length(xp{ii});
            keepnan = false(size(xp));
            keepnan((nx/2)+1:end) = true;
            isn = (isnan(xp{ii}) | isnan(yp{ii})) & ~keepnan;
        else
            isn = isnan(xp{ii}) | isnan(yp{ii});
        end
        xp{ii} = xp{ii}(~isn);
        yp{ii} = yp{ii}(~isn);
    end
    
end

if strcmp(nanflag, 'gap')
    [xp, yp] = singlepatch(xp, yp);
else
    xp = xp{1};
    yp = yp{1};
end


##### SOURCE END #####
--></body></html>