
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>asymp_dtf</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-10-08"><meta name="DC.source" content="asymp_dtf.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> c = asymp_dtf(u,A,pf,nFreqs,metric,alpha)
<span class="comment">%ASYMP_DTF   Compute DTF connectivity measures magnitude, from series j--&gt;i, for</span>
<span class="comment">%            any of three of metrics --- Euclidean, diagonal and information ---</span>
<span class="comment">%            as well as asymptotic statistics from vector autoregressive (VAR)</span>
<span class="comment">%            coefficients in the frequency domain.</span>
<span class="comment">%</span>
<span class="comment">% Syntax:</span>
<span class="comment">%        c = ASYMP_DTF(u,A,pf,nFreqs,metric,alpha)</span>
<span class="comment">%</span>
<span class="comment">% Input Arguments:</span>
<span class="comment">%        u      - multiple row vectors time series</span>
<span class="comment">%        A      - AR estimate matrix obtained via MVAR routine</span>
<span class="comment">%        pf     - covariance matrix provided via MVAR routine</span>
<span class="comment">%        nFreqs - number of point in [0,fs/2) frequency scale</span>
<span class="comment">%        metric - 'euc':  -- Euclidean   ==&gt; original DTF</span>
<span class="comment">%                 'diag': -- diagonal    ==&gt; DC (directed coherence)</span>
<span class="comment">%                 'info': -- information ==&gt; iDTF</span>
<span class="comment">%        alpha  - significance level</span>
<span class="comment">%                 if alpha is zero, statistical analysis won't be performed</span>
<span class="comment">%</span>
<span class="comment">% Output Arguments:</span>
<span class="comment">%        c struct variable with following fields:</span>
<span class="comment">%        |-- .dtf       - complex DTF estimates</span>
<span class="comment">%        |-- .dtf2      - |DTF|^2 estimates</span>
<span class="comment">%        |-- .pvalues   - p-values associated to DTF2 estimates.</span>
<span class="comment">%        |-- .th        - |DTF|^2 threshold value with (1-alpha) significance</span>
<span class="comment">%        |                level.</span>
<span class="comment">%        |-- .{ci1,ci2} - lower and upper (1 - alpha) confidence interval of</span>
<span class="comment">%        |                |DTF|^2 estimates</span>
<span class="comment">%        |-- .metric    - metric used for DTF calculation</span>
<span class="comment">%        |-- .alpha     - significance level</span>
<span class="comment">%        |-- .p         - VAR model order</span>
<span class="comment">%        |-- .patdenr   -</span>
<span class="comment">%        |-- .patdfr    - degree of freedom</span>
<span class="comment">%        |-- .SS        - power spectra</span>
<span class="comment">%        +-- .coh2      - squared spectral coherence</span>
<span class="comment">%    or</span>
<span class="comment">%        c.{dtf,dtf2,pvalues,th,ci1,ci2,metric,alpha,p,patdenr,patdfr,SS,coh2}</span>
<span class="comment">%</span>
<span class="comment">% Description:</span>
<span class="comment">%   Compute all three types of DTF --- Granger influentiability measure and</span>
<span class="comment">%   their allied statistical measures of asymptotic statistics for metric</span>
<span class="comment">%   option:</span>
<span class="comment">%        * 'euc'  - original or Euclidean DTF as proposed in [Kaminski &amp;</span>
<span class="comment">%                   Blinowska, 2001];</span>
<span class="comment">%        * 'diag' - Directed Coherence (DC) or gDTF (generalized);</span>
<span class="comment">%        * 'info' - information DTF.</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">%</span>
<span class="comment">%  Annual sunspot numbers  and the melanoma cases (10^5) in the State of</span>
<span class="comment">%  Connecticuts, USA, from 1936 to 1972, given by</span>
<span class="comment">%</span>
<span class="comment">%   u = [ 40 115 100  80  60  40  23  10  10  25  75 145 130 130  80  65  20 ...</span>
<span class="comment">%         10   5  10  60 190 180 175 120  50  35  20  10  15  30  60 105 105 ...</span>
<span class="comment">%         105  80  65; ...</span>
<span class="comment">%        0.9 0.8 0.8 1.3 1.4 1.2 1.7 1.8 1.6 1.5 1.5 2.0 2.5 2.7 2.9 2.5 3.1 ...</span>
<span class="comment">%        2.4 2.2 2.9 2.5 2.6 3.2 3.8 4.2 3.9 3.7 3.3 3.7 3.9 4.1 3.8 4.7 4.4 ...</span>
<span class="comment">%        4.8 4.8 4.8];</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   [nChannels,nSegLength] =size(u);</span>
<span class="comment">%   if nChannels &gt; nSegLength, u = u.'; [nChannels,nSegLength]=size(u); end;</span>
<span class="comment">%   for i=1:nChannels, u(i,:)=detrend(u(i,:)); end;</span>
<span class="comment">%</span>
<span class="comment">%   A        = [ 0.8280  -12.1097; 0.0009   -0.1258]; % VAR model estimate.</span>
<span class="comment">%   A(:,:,2) = [-0.0724   13.4798; 0.0036   -0.1391];</span>
<span class="comment">%   A(:,:,3) = [-0.3561  -36.4805; 0.0013   -0.0735];</span>
<span class="comment">%</span>
<span class="comment">%   pf = [568.0873  -1.5815; -1.5815 0.0474];</span>
<span class="comment">%</span>
<span class="comment">%   nFreqs = 128;     % number of points to calculate DTF in the frequency scale</span>
<span class="comment">%   metric = 'info';  % calculating information DTF</span>
<span class="comment">%   alpha  = 0.01;    % significance level</span>
<span class="comment">%   c = asymp_dtf(u,A,pf,nFreqs,metric,alpha); % Calculate iDTF with statistics</span>
<span class="comment">%</span>
<span class="comment">%   chLabels={'Sunspot';'Melanoma'}; % Channel labels</span>
<span class="comment">%   flgColor    = 0;      fs = 1;    w_max = 0.5;</span>
<span class="comment">%   flgPrinting =[1 1 1 2 2 0 1]; flgScale = 1;</span>
<span class="comment">%   flgMax      = 'all';    flgSignifColor = 3;</span>
<span class="comment">%   figure; xplot(c) % Visualiza PDC plots. Try this first.</span>
<span class="comment">%</span>
<span class="comment">%   figure;</span>
<span class="comment">%   xplot(c,flgPrinting,fs,w_max,chLabels,flgColor); % DTF plot with confidence</span>
<span class="comment">%                                                    % interval</span>
<span class="comment">%   figure;</span>
<span class="comment">%   xplot(c,flgPrinting,fs,fs/2,chLabels,flgColor,flgScale,flgMax, ...</span>
<span class="comment">%                                                              flgSignifColor);</span>
<span class="comment">%</span>
<span class="comment">% References:</span>
<span class="comment">%   [1] M.J. Kaminski and K.J. Blinowska. A new method of the description of the</span>
<span class="comment">%   information flow in the brain structures. Biol Cybern 65:203--210,1991.</span>
<span class="comment">%   &lt;https://doi.org/10.1007/bf00198091&gt;</span>
<span class="comment">%</span>
<span class="comment">%   [2] L.A.B. Baccala, D.Y. Takahashi and K. Sameshima. Directed transfer</span>
<span class="comment">%   function: unified asymptotic theory and some of its implications. IEEE T</span>
<span class="comment">%   Bio-Med Eng 63:2450--2460, 2016.</span>
<span class="comment">%   &lt;https://doi.org/10.1109/TBME.2016.2550199&gt;</span>
<span class="comment">%</span>
<span class="comment">% See also: DTF_ALG, ASYMP_PDC, MVAR, MCARNS, MCARVM, CMLSM, ARFIT</span>

<span class="comment">% (C) Koichi Sameshima &amp; Luiz A. Baccal&aacute;, 2022.</span>
<span class="comment">% See file license.txt in installation directory for licensing terms.</span>


<span class="keyword">if</span> ~(nargin == 6)
   error(<span class="string">'ASYMP_DTF requires six input arguments.'</span>)
<span class="keyword">end</span>
[m,n] = size(u);
<span class="keyword">if</span> m &gt; n
   u = u.';
<span class="keyword">end</span>
np = length(u);
[nChannels,~,p] = size(A);
Af = A_to_f(A, nFreqs);

flgVerbose = 0;

<span class="comment">% Variables pre-alocation</span>
dtf  = zeros(nChannels,nChannels,nFreqs); <span class="comment">% dtf will hold complex DTF estimates</span>
dtf2 = zeros(nChannels,nChannels,nFreqs);

<span class="keyword">if</span> alpha ~= 0
   th  = zeros(nChannels,nChannels,nFreqs);
   ci1 = zeros(nChannels,nChannels,nFreqs);
   ci2 = zeros(nChannels,nChannels,nFreqs);
   varass1 = zeros(nChannels,nChannels,nFreqs);
   varass2 = zeros(nChannels,nChannels,nFreqs);
   patdfr = zeros(nChannels,nChannels,nFreqs);
   patdenr = zeros(nChannels,nChannels,nFreqs);
   pvalues = zeros(nChannels,nChannels,nFreqs);

   <span class="keyword">if</span> flgVerbose
      <span class="keyword">switch</span> lower(metric)
         <span class="keyword">case</span> {<span class="string">'euc'</span>}
            disp(<span class="string">'* Original DTF and asymptotic statistics'</span>)
         <span class="keyword">case</span> {<span class="string">'diag'</span>}
            disp(<span class="string">'* Generalized DTF or DC and asymptotic statistics'</span>)
         <span class="keyword">case</span> {<span class="string">'info'</span>}
            disp(<span class="string">'* Information DTF and asymptotic statistics'</span>)
         <span class="keyword">otherwise</span>
            error(<span class="string">'Unknown metric.'</span>)
      <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">elseif</span> flgVerbose
   <span class="keyword">switch</span> lower(metric)
      <span class="keyword">case</span> {<span class="string">'euc'</span>}
         disp(<span class="string">'* Original DTF estimation'</span>)
      <span class="keyword">case</span> {<span class="string">'diag'</span>}
         disp(<span class="string">'* Generalized DTF/DC estimation'</span>)
      <span class="keyword">case</span> {<span class="string">'info'</span>}
         disp(<span class="string">'* Information DTF estimation'</span>)
      <span class="keyword">otherwise</span>
         error(<span class="string">'Unknown metric.'</span>)
   <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">switch</span> lower(metric)
   <span class="keyword">case</span> {<span class="string">'euc'</span>}               <span class="comment">% for DTF</span>
      ddtf_dev = zeros(1,nChannels^2);
      pfe  = eye(nChannels);  <span class="comment">% for complex DTF calculation</span>

   <span class="keyword">case</span> {<span class="string">'diag'</span>}              <span class="comment">% for DC</span>
      evar_d = mdiag(pf);
      evar_d_big = kron(eye(2),kron(evar_d,eye(nChannels)));

      debig_de = fdebig_de_dtf(nChannels); <span class="comment">%New Theta_K</span>
      dedinv_deh = debig_de*diag(vec(eye(nChannels)));
      pfe = pf;                <span class="comment">% for complex DC calculation</span>

   <span class="keyword">case</span> {<span class="string">'info'</span>}               <span class="comment">% for iDTF</span>
      evar_d = mdiag(pf);
      evar_d_big = kron(eye(2),kron(evar_d,eye(nChannels)));
      evar_big = kron(eye(2),kron(pf,eye(nChannels)));

      debig_de = fdebig_de_dtf(nChannels); <span class="comment">%New Theta_K</span>
      dedinv_deh = debig_de*diag(vec(eye(nChannels)));
      pfe = pf;                <span class="comment">% for complex iDTF calculation</span>

   <span class="keyword">otherwise</span>
      error(<span class="string">'Unknown metric.'</span>)
<span class="keyword">end</span>

gamma = bigautocorr(u, p);
omega = kron(pinv(gamma), pf);
omega_evar = 2*Dup(nChannels)*pinv(Dup(nChannels))*kron(pf, pf) <span class="keyword">...</span>
                            *(pinv(Dup(nChannels)).')*Dup(nChannels).';

icdf_norm_alpha = norminv(1 - alpha/2.0,0,1);

<span class="keyword">for</span> ff = 1:nFreqs
   f = (ff - 1)/(2*nFreqs); <span class="comment">% Corrected 7/25/2011, f starts at 0.</span>
   Ca = fCa(f, p, nChannels);

   Af_ff = reshape(Af(ff,:,:),[nChannels, nChannels]);
   Hf = pinv(Af_ff); h = Hf(:);  <span class="comment">% Equivalent to h = vec(Af[ff, :, :].I)</span>

   h = [real(h); imag(h)];    <span class="comment">% h = cat(h.real, h.imag, 0)</span>
   H = fdh_da(Af_ff);         <span class="comment">% = ha; H = fdh_da(mat(Af[ff, :, :]), n)</span>

   Omega_h = H*Ca*omega*Ca.'*H.';  <span class="comment">% \Omega_h</span>
   L = fChol(Omega_h); <span class="comment">% real-part only</span>

   <span class="keyword">for</span> i = 1:nChannels
      Ii = fIi(i,nChannels);

      <span class="keyword">switch</span> lower(metric)
         <span class="keyword">case</span> {<span class="string">'euc'</span>}           <span class="comment">% for DTF</span>
            Iie  = Ii;
         <span class="keyword">case</span> {<span class="string">'diag'</span>}          <span class="comment">% for DC</span>
            Iie  = Ii*evar_d_big*Ii;
         <span class="keyword">case</span> {<span class="string">'info'</span>}          <span class="comment">% for iDTF</span>
            Iie  = Ii*evar_big;
         <span class="keyword">otherwise</span>
            error(<span class="string">'Unknown metric.'</span>)
      <span class="keyword">end</span>

      <span class="keyword">for</span> j = 1:nChannels
         Iij = fIij(i,j,nChannels);

         <span class="keyword">switch</span> lower(metric)
            <span class="keyword">case</span> {<span class="string">'euc'</span>}               <span class="comment">% for DTF</span>
               Iije = Iij;

            <span class="keyword">case</span> {<span class="string">'diag'</span>}              <span class="comment">% for DC</span>
               Iije = Iij*evar_d_big*Iij;

            <span class="keyword">case</span> {<span class="string">'info'</span>}              <span class="comment">% for iDTF</span>
               Iije = Iij*evar_d_big;

            <span class="keyword">otherwise</span>
               error(<span class="string">'Unknown metric.'</span>)
         <span class="keyword">end</span>

         num = h.'*Iije*h;
         den = h.'*Iie*h;

         dtf2(i,j,ff) = num/den; <span class="comment">% |DTF_{ij}(ff)|^2 squared-|DTF|</span>
         dtf(i,j,ff)  = Hf(i,j)*sqrt(pfe(j,j))/sqrt(den); <span class="comment">% complex-DTF</span>

         <span class="comment">% If alpha == 0, do not calculate statistics for faster DTF computation.</span>
         <span class="keyword">if</span> alpha ~= 0
            <span class="comment">%'Add evar differentiation'</span>
            <span class="keyword">switch</span> lower(metric)
               <span class="keyword">case</span> {<span class="string">'euc'</span>}               <span class="comment">% for DTF</span>
                  <span class="comment">%nop</span>

               <span class="keyword">case</span> {<span class="string">'diag'</span>}              <span class="comment">% for DC</span>
                  dnum_dev = kron((Iij*h).', h.'*Iij)*dedinv_deh;
                  <span class="comment">%'derivative of den by vecE'</span>
                  dden_dev = kron((Ii*h).', h.'*Ii)*dedinv_deh;
                  ddtf_dev = (den*dnum_dev - num*dden_dev)/(den^2);

               <span class="keyword">case</span> {<span class="string">'info'</span>}              <span class="comment">% for iDTF</span>
                  <span class="comment">%'derivative of num by vecE'</span>
                  dnum_dev = kron((Iij*h).', h.'*Iij) * dedinv_deh;
                  <span class="comment">%'derivative of den by vecE'</span>
                  dden_dev = kron((Ii*h).', h.'*Ii) * debig_de;
                  ddtf_dev = (den*dnum_dev - num*dden_dev)/(den^2);

               <span class="keyword">otherwise</span>
                  error(<span class="string">'Unknown metric.'</span>)
            <span class="keyword">end</span>

            G1h = 2*h.'*Iije/den - 2*num*h.'*Iie/(den^2); <span class="comment">% Eq. (15)</span>
            <span class="comment">%   G1 = -G1h*H*Ca;                           % (Cont.)</span>
            varalpha = G1h*Omega_h*G1h.';
            varevar = ddtf_dev*omega_evar*ddtf_dev.';
            varass1(i,j,ff) = (varalpha + varevar)/np;    <span class="comment">% Eq. (14)</span>

            ci1(i,j,ff) = dtf2(i,j,ff) <span class="keyword">...</span>
                          - sqrt(varass1(i,j,ff))*icdf_norm_alpha;
            ci2(i,j,ff) = dtf2(i,j,ff) <span class="keyword">...</span>
                          + sqrt(varass1(i,j,ff))*icdf_norm_alpha;

            G2h = Iije/den;
            d = fEig(real(L), real(G2h)); <span class="comment">% real() 28May2013</span>

            patdf = (sum(d).^2)./sum(d.^2);
            patden = sum(d)./sum(d.^2);

             th(i,j,ff) = chi2inv((1 - alpha), patdf)/(patden*np); <span class="comment">% original KS</span>
<span class="comment">%            th(i,j,ff) = chi2inv((1 - alpha), patdf)./(np);</span>
            pvalues(i,j,ff) = 1 - chi2cdf(dtf2(i,j,ff)*patden*np, patdf);

            varass2(i,j,ff) = patdf/(patden*np).^2;
            patdfr(i,j,ff) = patdf;
            patdenr(i,j,ff) = patden;

         <span class="keyword">else</span> <span class="comment">% as alpha == 0, do not compute asymptotics</span>
            <span class="comment">%nop</span>
         <span class="keyword">end</span>
      <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> alpha ~= 0
   c.dtf = dtf;   <span class="comment">% Complex DTF2/DC2/iDTF2</span>
   c.dtf2 = dtf2;
   c.th = th;
   c.ci1 = ci1;  <span class="comment">% Lower CI</span>
   c.ci2 = ci2;  <span class="comment">% Upper CI</span>
   c.metric = metric;
   c.alpha = alpha;
   c.p = p;
   c.pvalues = pvalues; <span class="comment">% p-values associated to DTF2/DC2/iDTF2</span>
   c.patden = patdenr;
   c.patdf = patdfr;
   c.varass1 = varass1;
   c.varass2 = varass2;

   <span class="comment">% Statistically significant DTF2 on frequency scale</span>
   dtf2_temp = ((abs(dtf2) - abs(th)) &gt; 0).*dtf2 <span class="keyword">...</span>
                                           + ((abs(dtf2) - abs(th)) &lt;= 0)*(-1);
   dtf2_temp(dtf2_temp &lt; 0) = NaN; <span class="comment">% Octave</span>
   c.dtf2_th = dtf2_temp;

<span class="keyword">else</span>
    c.dtf = dtf;
    c.dtf2 = dtf2;
    c.metric = metric;
    c.alpha = 0;
    c.p = p;
    c.th = [];
    c.ci1 = [];
    c.ci2 = [];
    c.pvalues = [];
    c.patden = [];
    c.patdf = [];
    c.varass1 = [];
    c.varass2 = [];
<span class="keyword">end</span>

<span class="comment">% Power spectra and coherence calculation</span>
c.SS = ss_alg(A, pf, nFreqs);
c.coh2 = coh_alg(c.SS);
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> gamma = bigautocorr(x, p)
<span class="comment">%Autocorrelation. Data in rows. From order 0 to p-1.</span>
<span class="comment">%Output: n x n blocks of autocorr of lags i. (Nuttall Strand matrix)'''</span>
[n, nd] = size(x);

gamma = zeros(n*p, n*p);
<span class="keyword">for</span> i = 1:p
   <span class="keyword">for</span> j = 1:p
      gamma(((i - 1)*n + 1):i*n, ((j - 1)*n + 1):j*n) = <span class="keyword">...</span>
                                       xlag(x, i - 1)*(xlag(x,j - 1).')/nd;
   <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> c = xlag(x,tlag)
<span class="keyword">if</span> tlag == 0
   c = x;
<span class="keyword">else</span>
   c = zeros(size(x));
   c(:,(tlag + 1):end) = x(:,1:(end - tlag));
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> d = fEig(L, G2)
<span class="comment">%'''Returns the eigenvalues'''</span>

<span class="comment">%L = mat(cholesky(omega, lower=1))</span>
D = L.'*G2*L;
<span class="comment">%    d = eigh(D, eigvals_only=True)</span>
<span class="comment">%disp('fEig: eig or svd?')</span>
d = svd(D);
d1 = sort(d);
<span class="comment">%</span>
<span class="comment">% the two biggest eigenvalues no matter which values (non negative by</span>
<span class="comment">% construction</span>
<span class="comment">%</span>
d = d1(length(d) - 1:length(d));

<span class="keyword">if</span> (size(d) &gt; 2)
   disp(<span class="string">'More than two Chi-squares in the sum:'</span>)
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> c = fIij(i,j,n)
<span class="comment">%'''Returns Iij of the formula'''</span>
Iij = zeros(1,n^2);
Iij(n*(j - 1) + i) = 1;
Iij = diag(Iij);
c = kron(eye(2), Iij);
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="comment">% function c = fIj(j,n)</span>
<span class="comment">% %'''Returns Ij of the formula'''</span>
<span class="comment">% Ij = zeros(1,n);</span>
<span class="comment">% Ij(j) = 1;</span>
<span class="comment">% Ij = diag(Ij);</span>
<span class="comment">% Ij = kron(Ij,eye(n));</span>
<span class="comment">% c = kron(eye(2), Ij);</span>
<span class="comment">% end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> c = fIi(i,n)
<span class="comment">%    '''Returns Ii of the formula'''</span>
Ii = zeros(1,n);
Ii(i) = 1;
Ii = diag(Ii);
Ii = kron(eye(n), Ii);
c = kron(eye(2), Ii);
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> d = fCa(f, p, n)
<span class="comment">%'''Returns C* of the formula'''</span>
C1 = cos(-2*pi*f*(1:p));
S1 = sin(-2*pi*f*(1:p));
C2 = [C1; S1];
d = kron(C2, eye(n^2));
<span class="keyword">end</span>
<span class="comment">%==========================================================================</span>
<span class="comment">% function c = fdebig_de(n)</span>
<span class="comment">% %'''Derivative of kron(I(2n), A) by A'''</span>
<span class="comment">% %c = kron(TT(2*n, n), eye(n*2*n)) * kron(eye(n), kron(vec(eye(2*n)), eye(n)));</span>
<span class="comment">% A=sparse(kron(TT(2*n, n), eye(n*2*n)));</span>
<span class="comment">% B=sparse(kron(vec(eye(2*n)), eye(n)));</span>
<span class="comment">% c = A * kron(eye(n), B);</span>
<span class="comment">% c=sparse(c);</span>
<span class="comment">% end</span>
<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> c = fdebig_de_dtf(n)
<span class="comment">%''' New \Theta_K for DTF asymptotics'''</span>
<span class="comment">%c = kron(kron(eye(2*n),TT(n, 2*n)), eye(n)));</span>
<span class="comment">%A=sparse(kron(eye(2*n), TT(n, 2*n)));</span>
<span class="comment">%c=sparse(kron(A, eye(n)));</span>
A=sparse(kron(TT(n^2,2),eye(n^2)));
A1=sparse(kron(eye(2),A));
A=sparse(kron(TT(n^2,1),eye(n)));
<span class="comment">%A=sparse(kron(TT(1,n^2),eye(n)));</span>
A2=sparse(kron(eye(n),A));
A3=sparse(kron(eye(n^2),vec(eye(n))));
A4=sparse(A2*A3);
A5=sparse(kron(vec(eye(2)),A4));
c=sparse(A1*A5);
<span class="comment">% To generate sparse matrix</span>
<span class="comment">%c=sparse(c*diag(vec(eye(n))));</span>
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> c = vec(x)
<span class="comment">%vec = lambda x: mat(x.ravel('F')).T</span>
c=x(:);
<span class="keyword">end</span>
<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> t = TT(a,b)
<span class="comment">%''' TT(a,b)*vec(B) = vec(B.T), where B is (a x b).'''</span>
t = zeros(a*b);
<span class="keyword">for</span> i = 1:a
   <span class="keyword">for</span> j =1:b
      t((i - 1)*b + j,(j - 1)*a + i) = 1;
   <span class="keyword">end</span>
<span class="keyword">end</span>
t = sparse(t);
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> L = fChol(omega)
<span class="comment">% Try Cholesky factorization</span>
<span class="keyword">try</span>
   L = chol(omega)';
   <span class="comment">% If there's a small negative eigenvalue, diagonalize</span>
<span class="keyword">catch</span> <span class="comment">% err</span>
   <span class="comment">%   disp('linalgerror, probably IP = 1.')</span>
   [v,d] = eig(omega);
   L = zeros(size(v));
   <span class="keyword">for</span> i =1:length(d)
      <span class="keyword">if</span> d(i,i)&lt;0
         d(i,i)=eps;
      <span class="keyword">end</span>
      L(:,i) = v(:,i)*sqrt(d(i,i));
   <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> c = mdiag(a)
<span class="comment">%  diagonal matrix</span>
c = diag(diag(a));
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> d = Dup(n)
<span class="comment">%     '''D*vech(A) = vec(A), with symmetric A'''</span>
d = zeros(n*n, (n*(n + 1))/2);
count = 1;
<span class="keyword">for</span> j= 1:n
   <span class="keyword">for</span> i = 1:n
      <span class="keyword">if</span> i &gt;= j
         d((j - 1)*n + i,count)=1;
         count = count + 1;
      <span class="keyword">else</span>
         d((j - 1)*n + i,:)=d((i - 1)*n + j,:);
      <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%==========================================================================</span>
<span class="keyword">function</span> hh=fdh_da(Af)
<span class="comment">%    '''Derivative of vec(H) by vec(A), with $H = A^{-1}$ and complex A.'''</span>
ha = pinv(Af);
h = -kron(ha.', ha);

h1 = [real(h) -imag(h)];
h2 = [imag(h) real(h)];   <span class="comment">%h2 = cat(h.imag, h.real, 1)</span>
hh = -[h1; h2];           <span class="comment">%hh = cat(h1, h2, 0)</span>
<span class="keyword">end</span>
<span class="comment">%==========================================================================</span>

<span class="comment">%</span>
<span class="comment">%        1         2         3         4         5         6         7         8         9</span>
<span class="comment">%23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890</span>
<span class="comment">% Change Log:</span>
<span class="comment">% [2011/07/25]: The asymp_pdc routine, which asymp_dtf is derived from, was corrected on</span>
<span class="comment">%              to match the frequency range with plotting routine, f = 0 was</span>
<span class="comment">%              included in the "frequency" for-loop:</span>
<span class="comment">%                                for ff = 1:nFreqs,</span>
<span class="comment">%                                   f = (ff-1)/(2*nFreqs); %</span>
<span class="comment">%                                        ^?^^</span>
<span class="comment">% [2021/09/02, LAB]: complex dtf calculation added</span>
<span class="comment">%</span>
<span class="comment">% [2015/01/07]: Optimization \(^o^)/</span>

<span class="comment">% [EOF]</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
function c = asymp_dtf(u,A,pf,nFreqs,metric,alpha)
%ASYMP_DTF   Compute DTF connectivity measures magnitude, from series jREPLACE_WITH_DASH_DASH>i, for
%            any of three of metrics REPLACE_WITH_DASH_DASH- Euclidean, diagonal and information REPLACE_WITH_DASH_DASH-
%            as well as asymptotic statistics from vector autoregressive (VAR)
%            coefficients in the frequency domain.
%
% Syntax:
%        c = ASYMP_DTF(u,A,pf,nFreqs,metric,alpha)
%
% Input Arguments:
%        u      - multiple row vectors time series
%        A      - AR estimate matrix obtained via MVAR routine
%        pf     - covariance matrix provided via MVAR routine
%        nFreqs - number of point in [0,fs/2) frequency scale
%        metric - 'euc':  REPLACE_WITH_DASH_DASH Euclidean   ==> original DTF
%                 'diag': REPLACE_WITH_DASH_DASH diagonal    ==> DC (directed coherence)
%                 'info': REPLACE_WITH_DASH_DASH information ==> iDTF
%        alpha  - significance level
%                 if alpha is zero, statistical analysis won't be performed
%
% Output Arguments:
%        c struct variable with following fields:
%        |REPLACE_WITH_DASH_DASH .dtf       - complex DTF estimates
%        |REPLACE_WITH_DASH_DASH .dtf2      - |DTF|^2 estimates
%        |REPLACE_WITH_DASH_DASH .pvalues   - p-values associated to DTF2 estimates. 
%        |REPLACE_WITH_DASH_DASH .th        - |DTF|^2 threshold value with (1-alpha) significance 
%        |                level.
%        |REPLACE_WITH_DASH_DASH .{ci1,ci2} - lower and upper (1 - alpha) confidence interval of 
%        |                |DTF|^2 estimates
%        |REPLACE_WITH_DASH_DASH .metric    - metric used for DTF calculation 
%        |REPLACE_WITH_DASH_DASH .alpha     - significance level
%        |REPLACE_WITH_DASH_DASH .p         - VAR model order
%        |REPLACE_WITH_DASH_DASH .patdenr   - 
%        |REPLACE_WITH_DASH_DASH .patdfr    - degree of freedom 
%        |REPLACE_WITH_DASH_DASH .SS        - power spectra
%        +REPLACE_WITH_DASH_DASH .coh2      - squared spectral coherence
%    or
%        c.{dtf,dtf2,pvalues,th,ci1,ci2,metric,alpha,p,patdenr,patdfr,SS,coh2}
%
% Description:
%   Compute all three types of DTF REPLACE_WITH_DASH_DASH- Granger influentiability measure and
%   their allied statistical measures of asymptotic statistics for metric
%   option:
%        * 'euc'  - original or Euclidean DTF as proposed in [Kaminski &
%                   Blinowska, 2001];
%        * 'diag' - Directed Coherence (DC) or gDTF (generalized);
%        * 'info' - information DTF.
%
% Example:
% 
%  Annual sunspot numbers  and the melanoma cases (10^5) in the State of
%  Connecticuts, USA, from 1936 to 1972, given by
%
%   u = [ 40 115 100  80  60  40  23  10  10  25  75 145 130 130  80  65  20 ...
%         10   5  10  60 190 180 175 120  50  35  20  10  15  30  60 105 105 ...
%         105  80  65; ...
%        0.9 0.8 0.8 1.3 1.4 1.2 1.7 1.8 1.6 1.5 1.5 2.0 2.5 2.7 2.9 2.5 3.1 ...
%        2.4 2.2 2.9 2.5 2.6 3.2 3.8 4.2 3.9 3.7 3.3 3.7 3.9 4.1 3.8 4.7 4.4 ...
%        4.8 4.8 4.8];
%
%
%   [nChannels,nSegLength] =size(u);
%   if nChannels > nSegLength, u = u.'; [nChannels,nSegLength]=size(u); end;
%   for i=1:nChannels, u(i,:)=detrend(u(i,:)); end;
%
%   A        = [ 0.8280  -12.1097; 0.0009   -0.1258]; % VAR model estimate.
%   A(:,:,2) = [-0.0724   13.4798; 0.0036   -0.1391];
%   A(:,:,3) = [-0.3561  -36.4805; 0.0013   -0.0735];
%
%   pf = [568.0873  -1.5815; -1.5815 0.0474];
%
%   nFreqs = 128;     % number of points to calculate DTF in the frequency scale
%   metric = 'info';  % calculating information DTF
%   alpha  = 0.01;    % significance level
%   c = asymp_dtf(u,A,pf,nFreqs,metric,alpha); % Calculate iDTF with statistics
%
%   chLabels={'Sunspot';'Melanoma'}; % Channel labels
%   flgColor    = 0;      fs = 1;    w_max = 0.5; 
%   flgPrinting =[1 1 1 2 2 0 1]; flgScale = 1; 
%   flgMax      = 'all';    flgSignifColor = 3;
%   figure; xplot(c) % Visualiza PDC plots. Try this first.
%
%   figure; 
%   xplot(c,flgPrinting,fs,w_max,chLabels,flgColor); % DTF plot with confidence
%                                                    % interval
%   figure; 
%   xplot(c,flgPrinting,fs,fs/2,chLabels,flgColor,flgScale,flgMax, ...
%                                                              flgSignifColor);
%
% References:
%   [1] M.J. Kaminski and K.J. Blinowska. A new method of the description of the
%   information flow in the brain structures. Biol Cybern 65:203REPLACE_WITH_DASH_DASH210,1991.
%   <https://doi.org/10.1007/bf00198091>
%
%   [2] L.A.B. Baccala, D.Y. Takahashi and K. Sameshima. Directed transfer
%   function: unified asymptotic theory and some of its implications. IEEE T
%   Bio-Med Eng 63:2450REPLACE_WITH_DASH_DASH2460, 2016. 
%   <https://doi.org/10.1109/TBME.2016.2550199>
%
% See also: DTF_ALG, ASYMP_PDC, MVAR, MCARNS, MCARVM, CMLSM, ARFIT

% (C) Koichi Sameshima & Luiz A. BaccalÃ¡, 2022. 
% See file license.txt in installation directory for licensing terms.


if ~(nargin == 6)
   error('ASYMP_DTF requires six input arguments.')
end
[m,n] = size(u);
if m > n
   u = u.';
end
np = length(u);
[nChannels,~,p] = size(A);
Af = A_to_f(A, nFreqs);

flgVerbose = 0;

% Variables pre-alocation
dtf  = zeros(nChannels,nChannels,nFreqs); % dtf will hold complex DTF estimates
dtf2 = zeros(nChannels,nChannels,nFreqs);

if alpha ~= 0
   th  = zeros(nChannels,nChannels,nFreqs);
   ci1 = zeros(nChannels,nChannels,nFreqs);
   ci2 = zeros(nChannels,nChannels,nFreqs);
   varass1 = zeros(nChannels,nChannels,nFreqs);
   varass2 = zeros(nChannels,nChannels,nFreqs);
   patdfr = zeros(nChannels,nChannels,nFreqs);
   patdenr = zeros(nChannels,nChannels,nFreqs);
   pvalues = zeros(nChannels,nChannels,nFreqs);
   
   if flgVerbose
      switch lower(metric)
         case {'euc'}
            disp('* Original DTF and asymptotic statistics')
         case {'diag'}
            disp('* Generalized DTF or DC and asymptotic statistics')
         case {'info'}
            disp('* Information DTF and asymptotic statistics')
         otherwise
            error('Unknown metric.')
      end
   end
elseif flgVerbose
   switch lower(metric)
      case {'euc'}
         disp('* Original DTF estimation')
      case {'diag'}
         disp('* Generalized DTF/DC estimation')
      case {'info'}
         disp('* Information DTF estimation')
      otherwise
         error('Unknown metric.')
   end
end

switch lower(metric)
   case {'euc'}               % for DTF
      ddtf_dev = zeros(1,nChannels^2);
      pfe  = eye(nChannels);  % for complex DTF calculation  
      
   case {'diag'}              % for DC
      evar_d = mdiag(pf);
      evar_d_big = kron(eye(2),kron(evar_d,eye(nChannels)));

      debig_de = fdebig_de_dtf(nChannels); %New Theta_K
      dedinv_deh = debig_de*diag(vec(eye(nChannels)));
      pfe = pf;                % for complex DC calculation

   case {'info'}               % for iDTF
      evar_d = mdiag(pf);
      evar_d_big = kron(eye(2),kron(evar_d,eye(nChannels)));
      evar_big = kron(eye(2),kron(pf,eye(nChannels)));

      debig_de = fdebig_de_dtf(nChannels); %New Theta_K
      dedinv_deh = debig_de*diag(vec(eye(nChannels)));
      pfe = pf;                % for complex iDTF calculation

   otherwise
      error('Unknown metric.')
end

gamma = bigautocorr(u, p);
omega = kron(pinv(gamma), pf);
omega_evar = 2*Dup(nChannels)*pinv(Dup(nChannels))*kron(pf, pf) ...
                            *(pinv(Dup(nChannels)).')*Dup(nChannels).';

icdf_norm_alpha = norminv(1 - alpha/2.0,0,1);

for ff = 1:nFreqs
   f = (ff - 1)/(2*nFreqs); % Corrected 7/25/2011, f starts at 0.
   Ca = fCa(f, p, nChannels);

   Af_ff = reshape(Af(ff,:,:),[nChannels, nChannels]);
   Hf = pinv(Af_ff); h = Hf(:);  % Equivalent to h = vec(Af[ff, :, :].I)

   h = [real(h); imag(h)];    % h = cat(h.real, h.imag, 0)
   H = fdh_da(Af_ff);         % = ha; H = fdh_da(mat(Af[ff, :, :]), n)

   Omega_h = H*Ca*omega*Ca.'*H.';  % \Omega_h
   L = fChol(Omega_h); % real-part only

   for i = 1:nChannels
      Ii = fIi(i,nChannels);

      switch lower(metric)
         case {'euc'}           % for DTF
            Iie  = Ii;
         case {'diag'}          % for DC
            Iie  = Ii*evar_d_big*Ii;
         case {'info'}          % for iDTF
            Iie  = Ii*evar_big;            
         otherwise
            error('Unknown metric.')
      end

      for j = 1:nChannels
         Iij = fIij(i,j,nChannels);

         switch lower(metric)
            case {'euc'}               % for DTF
               Iije = Iij;

            case {'diag'}              % for DC
               Iije = Iij*evar_d_big*Iij;

            case {'info'}              % for iDTF
               Iije = Iij*evar_d_big;

            otherwise
               error('Unknown metric.')
         end

         num = h.'*Iije*h;
         den = h.'*Iie*h;
         
         dtf2(i,j,ff) = num/den; % |DTF_{ij}(ff)|^2 squared-|DTF|
         dtf(i,j,ff)  = Hf(i,j)*sqrt(pfe(j,j))/sqrt(den); % complex-DTF
         
         % If alpha == 0, do not calculate statistics for faster DTF computation.
         if alpha ~= 0
            %'Add evar differentiation'
            switch lower(metric)
               case {'euc'}               % for DTF
                  %nop

               case {'diag'}              % for DC
                  dnum_dev = kron((Iij*h).', h.'*Iij)*dedinv_deh;
                  %'derivative of den by vecE'
                  dden_dev = kron((Ii*h).', h.'*Ii)*dedinv_deh;
                  ddtf_dev = (den*dnum_dev - num*dden_dev)/(den^2);
                  
               case {'info'}              % for iDTF
                  %'derivative of num by vecE'
                  dnum_dev = kron((Iij*h).', h.'*Iij) * dedinv_deh;
                  %'derivative of den by vecE'
                  dden_dev = kron((Ii*h).', h.'*Ii) * debig_de;
                  ddtf_dev = (den*dnum_dev - num*dden_dev)/(den^2);
                  
               otherwise
                  error('Unknown metric.')
            end

            G1h = 2*h.'*Iije/den - 2*num*h.'*Iie/(den^2); % Eq. (15)
            %   G1 = -G1h*H*Ca;                           % (Cont.)
            varalpha = G1h*Omega_h*G1h.';
            varevar = ddtf_dev*omega_evar*ddtf_dev.';
            varass1(i,j,ff) = (varalpha + varevar)/np;    % Eq. (14)

            ci1(i,j,ff) = dtf2(i,j,ff) ...
                          - sqrt(varass1(i,j,ff))*icdf_norm_alpha;
            ci2(i,j,ff) = dtf2(i,j,ff) ...
                          + sqrt(varass1(i,j,ff))*icdf_norm_alpha;

            G2h = Iije/den;
            d = fEig(real(L), real(G2h)); % real() 28May2013

            patdf = (sum(d).^2)./sum(d.^2);
            patden = sum(d)./sum(d.^2);

             th(i,j,ff) = chi2inv((1 - alpha), patdf)/(patden*np); % original KS 
%            th(i,j,ff) = chi2inv((1 - alpha), patdf)./(np);
            pvalues(i,j,ff) = 1 - chi2cdf(dtf2(i,j,ff)*patden*np, patdf);

            varass2(i,j,ff) = patdf/(patden*np).^2;
            patdfr(i,j,ff) = patdf;
            patdenr(i,j,ff) = patden;
            
         else % as alpha == 0, do not compute asymptotics
            %nop
         end
      end
   end
end

if alpha ~= 0
   c.dtf = dtf;   % Complex DTF2/DC2/iDTF2
   c.dtf2 = dtf2;
   c.th = th;
   c.ci1 = ci1;  % Lower CI
   c.ci2 = ci2;  % Upper CI
   c.metric = metric;
   c.alpha = alpha;
   c.p = p;
   c.pvalues = pvalues; % p-values associated to DTF2/DC2/iDTF2
   c.patden = patdenr;
   c.patdf = patdfr;
   c.varass1 = varass1;
   c.varass2 = varass2;
   
   % Statistically significant DTF2 on frequency scale
   dtf2_temp = ((abs(dtf2) - abs(th)) > 0).*dtf2 ...
                                           + ((abs(dtf2) - abs(th)) <= 0)*(-1);
   dtf2_temp(dtf2_temp < 0) = NaN; % Octave
   c.dtf2_th = dtf2_temp;
   
else
    c.dtf = dtf;
    c.dtf2 = dtf2;
    c.metric = metric;
    c.alpha = 0;
    c.p = p;
    c.th = [];
    c.ci1 = [];
    c.ci2 = [];
    c.pvalues = [];
    c.patden = [];
    c.patdf = [];
    c.varass1 = [];
    c.varass2 = [];
end

% Power spectra and coherence calculation
c.SS = ss_alg(A, pf, nFreqs);
c.coh2 = coh_alg(c.SS);
end

%==========================================================================
function gamma = bigautocorr(x, p)
%Autocorrelation. Data in rows. From order 0 to p-1.
%Output: n x n blocks of autocorr of lags i. (Nuttall Strand matrix)'''
[n, nd] = size(x);

gamma = zeros(n*p, n*p);
for i = 1:p
   for j = 1:p
      gamma(((i - 1)*n + 1):i*n, ((j - 1)*n + 1):j*n) = ...
                                       xlag(x, i - 1)*(xlag(x,j - 1).')/nd;
   end
end
end

%==========================================================================
function c = xlag(x,tlag)
if tlag == 0
   c = x;
else
   c = zeros(size(x));
   c(:,(tlag + 1):end) = x(:,1:(end - tlag));
end
end

%==========================================================================
function d = fEig(L, G2)
%'''Returns the eigenvalues'''

%L = mat(cholesky(omega, lower=1))
D = L.'*G2*L;
%    d = eigh(D, eigvals_only=True)
%disp('fEig: eig or svd?')
d = svd(D);
d1 = sort(d);
%
% the two biggest eigenvalues no matter which values (non negative by
% construction
%
d = d1(length(d) - 1:length(d));

if (size(d) > 2)
   disp('More than two Chi-squares in the sum:')
end
end

%==========================================================================
function c = fIij(i,j,n)
%'''Returns Iij of the formula'''
Iij = zeros(1,n^2);
Iij(n*(j - 1) + i) = 1;
Iij = diag(Iij);
c = kron(eye(2), Iij);
end

%==========================================================================
% function c = fIj(j,n)
% %'''Returns Ij of the formula'''
% Ij = zeros(1,n);
% Ij(j) = 1;
% Ij = diag(Ij);
% Ij = kron(Ij,eye(n));
% c = kron(eye(2), Ij);
% end

%==========================================================================
function c = fIi(i,n)
%    '''Returns Ii of the formula'''
Ii = zeros(1,n);
Ii(i) = 1;
Ii = diag(Ii);
Ii = kron(eye(n), Ii);
c = kron(eye(2), Ii);
end

%==========================================================================
function d = fCa(f, p, n)
%'''Returns C* of the formula'''
C1 = cos(-2*pi*f*(1:p));
S1 = sin(-2*pi*f*(1:p));
C2 = [C1; S1];
d = kron(C2, eye(n^2));
end
%==========================================================================
% function c = fdebig_de(n)
% %'''Derivative of kron(I(2n), A) by A'''
% %c = kron(TT(2*n, n), eye(n*2*n)) * kron(eye(n), kron(vec(eye(2*n)), eye(n)));
% A=sparse(kron(TT(2*n, n), eye(n*2*n)));
% B=sparse(kron(vec(eye(2*n)), eye(n)));
% c = A * kron(eye(n), B);
% c=sparse(c);
% end
%==========================================================================
function c = fdebig_de_dtf(n)
%''' New \Theta_K for DTF asymptotics'''
%c = kron(kron(eye(2*n),TT(n, 2*n)), eye(n)));
%A=sparse(kron(eye(2*n), TT(n, 2*n)));
%c=sparse(kron(A, eye(n)));
A=sparse(kron(TT(n^2,2),eye(n^2)));
A1=sparse(kron(eye(2),A));
A=sparse(kron(TT(n^2,1),eye(n)));
%A=sparse(kron(TT(1,n^2),eye(n)));
A2=sparse(kron(eye(n),A));
A3=sparse(kron(eye(n^2),vec(eye(n))));
A4=sparse(A2*A3);
A5=sparse(kron(vec(eye(2)),A4));
c=sparse(A1*A5);
% To generate sparse matrix
%c=sparse(c*diag(vec(eye(n))));
end

%==========================================================================
function c = vec(x)
%vec = lambda x: mat(x.ravel('F')).T
c=x(:);
end
%==========================================================================
function t = TT(a,b)
%''' TT(a,b)*vec(B) = vec(B.T), where B is (a x b).'''
t = zeros(a*b);
for i = 1:a
   for j =1:b
      t((i - 1)*b + j,(j - 1)*a + i) = 1;
   end
end
t = sparse(t);
end

%==========================================================================
function L = fChol(omega)
% Try Cholesky factorization
try
   L = chol(omega)';
   % If there's a small negative eigenvalue, diagonalize
catch % err
   %   disp('linalgerror, probably IP = 1.')
   [v,d] = eig(omega);
   L = zeros(size(v));
   for i =1:length(d)
      if d(i,i)<0
         d(i,i)=eps;
      end
      L(:,i) = v(:,i)*sqrt(d(i,i));
   end
end
end

%==========================================================================
function c = mdiag(a)
%  diagonal matrix
c = diag(diag(a));
end

%==========================================================================
function d = Dup(n)
%     '''D*vech(A) = vec(A), with symmetric A'''
d = zeros(n*n, (n*(n + 1))/2);
count = 1;
for j= 1:n
   for i = 1:n
      if i >= j
         d((j - 1)*n + i,count)=1;
         count = count + 1;
      else
         d((j - 1)*n + i,:)=d((i - 1)*n + j,:);
      end
   end
end
end

%==========================================================================
function hh=fdh_da(Af)
%    '''Derivative of vec(H) by vec(A), with $H = A^{-1}$ and complex A.'''
ha = pinv(Af);
h = -kron(ha.', ha);

h1 = [real(h) -imag(h)];
h2 = [imag(h) real(h)];   %h2 = cat(h.imag, h.real, 1)
hh = -[h1; h2];           %hh = cat(h1, h2, 0)
end
%==========================================================================

%
%        1         2         3         4         5         6         7         8         9
%23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
% Change Log:
% [2011/07/25]: The asymp_pdc routine, which asymp_dtf is derived from, was corrected on
%              to match the frequency range with plotting routine, f = 0 was
%              included in the "frequency" for-loop:
%                                for ff = 1:nFreqs,
%                                   f = (ff-1)/(2*nFreqs); %
%                                        ^?^^
% [2021/09/02, LAB]: complex dtf calculation added
%
% [2015/01/07]: Optimization \(^o^)/

% [EOF]

##### SOURCE END #####
--></body></html>