
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ASYMP_DTF</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-06-29"><meta name="DC.source" content="asymp_dtf.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ASYMP_DTF</h1><!--introduction--><pre>      Compute DTF connectivity measures magnitude, from series j--&gt; i, for
      any of three types of metrics -- Euclidean, diagonal and information --
      as well as asymptotic statistics from vector autoregressive (VAR)
      coefficients in the frequency domain.</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Input Arguments</a></li><li><a href="#3">Output Arguments</a></li><li><a href="#4">Description</a></li><li><a href="#5">Example:</a></li><li><a href="#6">References</a></li><li><a href="#9">Change Log:</a></li></ul></div><h2 id="1">Syntax</h2><pre>      c = ASYMP_DTF(u,A,pf,nFreqs,metric,alpha)</pre><h2 id="2">Input Arguments</h2><pre>      u      - multiple time series
      A      - AR estimate matrix obtained via MVAR routine
      pf     - covariance matrix provided via MVAR routine
      nFreqs - number of point in [0,fs/2) frequency scale
      metric - 'euc':  -- Euclidean   ==&gt; original DTF
               'diag': -- diagonal    ==&gt; DC (directed coherence)
               'info': -- information ==&gt; iDTF
      alpha  - significance level
               if alpha is zero, statistical analysis won't be performed</pre><h2 id="3">Output Arguments</h2><pre>      c struct variable with following fields:
      |-- .dtf       - complex DTF estimates
      |-- .dtf2      - |DTF|^2 estimates
      |-- .pvalues   - p-values associated to DTF2 estimates.
      |-- .th        - |DTF|^2 threshold value with (1-avalue) significance
      |                level.
      |-- .{ci1,ci2} - lower and upper (1 - alpha) confidence interval of
      |                |DTF|^2 estimates
      |-- .metric    - metric used for DTF calculation
      |-- .alpha     - significance level
      |-- .p         - VAR model order
      |-- .patdenr   -
      |-- .patdfr    - degree of freedom
      |-- .SS        - power spectra
      +-- .coh2      - squared spectral coherence
  or
      c.{dtf,dtf2,pvalues,th,ci1,ci2,metric,alpha,p,patdenr,patdfr,SS,coh2}</pre><h2 id="4">Description</h2><pre class="language-matlab">Compute <span class="string">all</span> <span class="string">three</span> <span class="string">types</span> <span class="string">of</span> <span class="string">DTF</span> <span class="string">---</span> <span class="string">Granger</span> <span class="string">influentiability</span> <span class="string">measure</span> <span class="string">and</span>
their <span class="string">allied</span> <span class="string">statistical</span> <span class="string">measures</span> <span class="string">of</span> <span class="string">asymptotic</span> <span class="string">statistics</span> <span class="string">for</span> <span class="string">metric</span>
option:
     * <span class="string">'euc'</span>  - original or <span class="string">Euclidean</span> <span class="string">DTF</span> <span class="string">as</span> <span class="string">proposed</span> <span class="string">in</span> <span class="string">[Kaminski &amp;</span>
                Blinowska, 2001];
     * <span class="string">'diag'</span> - Directed Coherence (DC) or <span class="string">gDTF</span> <span class="string">(generalized)</span>;
     * <span class="string">'info'</span> - information DTF.
</pre><h2 id="5">Example:</h2><p>Annual sunspot numbers  and the melanoma cases (10^5) in the State of Connecticuts, USA, from 1936 to 1972, given by</p><pre class="language-matlab">u = [ 40 115 100  80  60  40  23  10  10  25  75 145 130 130  80  65  20 <span class="keyword">...</span>
      10   5  10  60 190 180 175 120  50  35  20  10  15  30  60 105 105 <span class="keyword">...</span>
      105  80  65; <span class="keyword">...</span>
     0.9 0.8 0.8 1.3 1.4 1.2 1.7 1.8 1.6 1.5 1.5 2.0 2.5 2.7 2.9 2.5 3.1 <span class="keyword">...</span>
     2.4 2.2 2.9 2.5 2.6 3.2 3.8 4.2 3.9 3.7 3.3 3.7 3.9 4.1 3.8 4.7 4.4 <span class="keyword">...</span>
     4.8 4.8 4.8];
</pre><pre class="language-matlab">[nChannels,nSegLength] =size(u);
<span class="keyword">if</span> nChannels &gt; nSegLength, u = u.'; [nChannels,nSegLength]=size(u); <span class="keyword">end</span>;
<span class="keyword">for</span> i=1:nChannels, u(i,:)=detrend(u(i,:)); <span class="keyword">end</span>;
</pre><pre class="language-matlab">A        = [ 0.8280  -12.1097; 0.0009   -0.1258]; <span class="comment">% VAR model estimate.</span>
A(:,:,2) = [-0.0724   13.4798; 0.0036   -0.1391];
A(:,:,3) = [-0.3561  -36.4805; 0.0013   -0.0735];
</pre><pre class="language-matlab">pf = [568.0873  -1.5815; -1.5815 0.0474];
</pre><pre class="language-matlab">nFreqs = 128;     <span class="comment">% number of points to calculate DTF in the frequency scale</span>
metric = <span class="string">'info'</span>;  <span class="comment">% calculating information DTF</span>
alpha  = 0.01;    <span class="comment">% significance level</span>
c = asymp_dtf(u,A,pf,nFreqs,metric,alpha); <span class="comment">% Calculate iDTF with statistics</span>
</pre><pre class="language-matlab">chLabels={<span class="string">'Sunspot'</span>;<span class="string">'Melanoma'</span>}; <span class="comment">% Channel labels</span>
flgColor    = 0;      fs = 1;    w_max = 0.5;
flgPrinting =[1 1 1 2 2 0 1]; flgScale = 1;
flgMax      = <span class="string">'all'</span>;    flgSignifColor = 3;
figure; xplot(c) <span class="comment">% Visualiza PDC plots. Try this first.</span>
</pre><pre class="language-matlab">figure;
xplot(c,flgPrinting,fs,w_max,chLabels,flgColor); <span class="comment">% DTF plot with confidence</span>
                                                 <span class="comment">% interval</span>
figure;
xplot(c,flgPrinting,fs,fs/2,chLabels,flgColor,flgScale,flgMax, <span class="keyword">...</span>
                                                           flgSignifColor);
</pre><h2 id="6">References</h2><pre class="language-matlab">[1] M.J. Kaminski and <span class="string">K.J.</span> <span class="string">Blinowska.</span> <span class="string">A</span> <span class="string">new</span> <span class="string">method</span> <span class="string">of</span> <span class="string">the</span> <span class="string">description</span> <span class="string">of</span> <span class="string">the</span>
information <span class="string">flow</span> <span class="string">in</span> <span class="string">the</span> <span class="string">brain</span> <span class="string">structures.</span> <span class="string">Biol</span> <span class="string">Cybern</span> <span class="string">65:203--210</span>,1991.
&lt;https://doi.org/10.1007/bf00198091&gt;
</pre><pre class="language-matlab">[2] L.A.B. Baccala, D.Y. Takahashi and <span class="string">K.</span> <span class="string">Sameshima.</span> <span class="string">Directed</span> <span class="string">transfer</span>
<span class="keyword">function</span>: unified asymptotic <span class="string">theory</span> <span class="string">and</span> <span class="string">some</span> <span class="string">of</span> <span class="string">its</span> <span class="string">implications.</span> <span class="string">IEEE</span> <span class="string">T</span>
Bio-Med Eng <span class="string">63:2450--2460</span>, 2016.
&lt;https://doi.org/10.1109/TBME.2016.2550199&gt;
</pre><p>See also DTF_ALG, ASYMP_PDC, MVAR, MCARNS, MCARVM, CMLSM, ARFIT,          asymp_dtf | <a href="asymp_dtf.html">asymp_dtf.html</a> <tt><a href="asymp_pdc.html">asymp_pdc.html</a></tt>% See also MVAR,          asymp_pdc, <a href="ASYMP_DTF.html">ASYMP_DTF.html</a>, XPLOT</p><pre>      1         2         3         4         5         6         7         8         9</pre><h2 id="9">Change Log:</h2><p>[2011/07/25]: The asymp_pdc routine, which asymp_dtf is derived from, was corrected on              to match the frequency range with plotting routine, f = 0 was              included in the "frequency" for-loop:                                for ff = 1:nFreqs,                                   f = (ff-1)/(2*nFreqs); %                                        ^?^^ [2021/09/02, LAB]: complex dtf calculation added</p><p>[2015/01/07]: Optimization \(^o^)/</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ASYMP_DTF
%        Compute DTF connectivity measures magnitude, from series jREPLACE_WITH_DASH_DASH> i, for
%        any of three types of metrics REPLACE_WITH_DASH_DASH Euclidean, diagonal and information REPLACE_WITH_DASH_DASH
%        as well as asymptotic statistics from vector autoregressive (VAR)
%        coefficients in the frequency domain.
%
%% Syntax
%        c = ASYMP_DTF(u,A,pf,nFreqs,metric,alpha)
%
%% Input Arguments
%        u      - multiple time series
%        A      - AR estimate matrix obtained via MVAR routine
%        pf     - covariance matrix provided via MVAR routine
%        nFreqs - number of point in [0,fs/2) frequency scale
%        metric - 'euc':  REPLACE_WITH_DASH_DASH Euclidean   ==> original DTF
%                 'diag': REPLACE_WITH_DASH_DASH diagonal    ==> DC (directed coherence)
%                 'info': REPLACE_WITH_DASH_DASH information ==> iDTF
%        alpha  - significance level
%                 if alpha is zero, statistical analysis won't be performed
%
%% Output Arguments 
%        c struct variable with following fields:
%        |REPLACE_WITH_DASH_DASH .dtf       - complex DTF estimates
%        |REPLACE_WITH_DASH_DASH .dtf2      - |DTF|^2 estimates
%        |REPLACE_WITH_DASH_DASH .pvalues   - p-values associated to DTF2 estimates. 
%        |REPLACE_WITH_DASH_DASH .th        - |DTF|^2 threshold value with (1-avalue) significance 
%        |                level.
%        |REPLACE_WITH_DASH_DASH .{ci1,ci2} - lower and upper (1 - alpha) confidence interval of 
%        |                |DTF|^2 estimates
%        |REPLACE_WITH_DASH_DASH .metric    - metric used for DTF calculation 
%        |REPLACE_WITH_DASH_DASH .alpha     - significance level
%        |REPLACE_WITH_DASH_DASH .p         - VAR model order
%        |REPLACE_WITH_DASH_DASH .patdenr   - 
%        |REPLACE_WITH_DASH_DASH .patdfr    - degree of freedom 
%        |REPLACE_WITH_DASH_DASH .SS        - power spectra
%        +REPLACE_WITH_DASH_DASH .coh2      - squared spectral coherence
%    or
%        c.{dtf,dtf2,pvalues,th,ci1,ci2,metric,alpha,p,patdenr,patdfr,SS,coh2}
%
%% Description
%   Compute all three types of DTF REPLACE_WITH_DASH_DASH- Granger influentiability measure and
%   their allied statistical measures of asymptotic statistics for metric
%   option:
%        * 'euc'  - original or Euclidean DTF as proposed in [Kaminski &
%                   Blinowska, 2001];
%        * 'diag' - Directed Coherence (DC) or gDTF (generalized);
%        * 'info' - information DTF.
%
%% Example:
% 
% Annual sunspot numbers  and the melanoma cases (10^5) in the State of
% Connecticuts, USA, from 1936 to 1972, given by
%
%   u = [ 40 115 100  80  60  40  23  10  10  25  75 145 130 130  80  65  20 ...
%         10   5  10  60 190 180 175 120  50  35  20  10  15  30  60 105 105 ...
%         105  80  65; ...
%        0.9 0.8 0.8 1.3 1.4 1.2 1.7 1.8 1.6 1.5 1.5 2.0 2.5 2.7 2.9 2.5 3.1 ...
%        2.4 2.2 2.9 2.5 2.6 3.2 3.8 4.2 3.9 3.7 3.3 3.7 3.9 4.1 3.8 4.7 4.4 ...
%        4.8 4.8 4.8];
%
%
%   [nChannels,nSegLength] =size(u);
%   if nChannels > nSegLength, u = u.'; [nChannels,nSegLength]=size(u); end;
%   for i=1:nChannels, u(i,:)=detrend(u(i,:)); end;
%
%   A        = [ 0.8280  -12.1097; 0.0009   -0.1258]; % VAR model estimate.
%   A(:,:,2) = [-0.0724   13.4798; 0.0036   -0.1391];
%   A(:,:,3) = [-0.3561  -36.4805; 0.0013   -0.0735];
%
%   pf = [568.0873  -1.5815; -1.5815 0.0474];
%
%   nFreqs = 128;     % number of points to calculate DTF in the frequency scale
%   metric = 'info';  % calculating information DTF
%   alpha  = 0.01;    % significance level
%   c = asymp_dtf(u,A,pf,nFreqs,metric,alpha); % Calculate iDTF with statistics
%
%   chLabels={'Sunspot';'Melanoma'}; % Channel labels
%   flgColor    = 0;      fs = 1;    w_max = 0.5; 
%   flgPrinting =[1 1 1 2 2 0 1]; flgScale = 1; 
%   flgMax      = 'all';    flgSignifColor = 3;
%   figure; xplot(c) % Visualiza PDC plots. Try this first.
%
%   figure; 
%   xplot(c,flgPrinting,fs,w_max,chLabels,flgColor); % DTF plot with confidence
%                                                    % interval
%   figure; 
%   xplot(c,flgPrinting,fs,fs/2,chLabels,flgColor,flgScale,flgMax, ...
%                                                              flgSignifColor);
%
%% References
%
%   [1] M.J. Kaminski and K.J. Blinowska. A new method of the description of the
%   information flow in the brain structures. Biol Cybern 65:203REPLACE_WITH_DASH_DASH210,1991.
%   <https://doi.org/10.1007/bf00198091>
%
%   [2] L.A.B. Baccala, D.Y. Takahashi and K. Sameshima. Directed transfer
%   function: unified asymptotic theory and some of its implications. IEEE T
%   Bio-Med Eng 63:2450REPLACE_WITH_DASH_DASH2460, 2016. 
%   <https://doi.org/10.1109/TBME.2016.2550199>
%
% See also DTF_ALG, ASYMP_PDC, MVAR, MCARNS, MCARVM, CMLSM, ARFIT,
%          asymp_dtf | <asymp_dtf.html> |<asymp_pdc.html>|% See also MVAR,
%          asymp_pdc, <ASYMP_DTF.html>, XPLOT
%

% (C) Koichi Sameshima & Luiz A. Baccala, 2021. See file license.txt in
% installation directory for licensing terms.

function c = asymp_dtf(u,A,pf,nFreqs,metric,alpha)

if ~(nargin == 6)
   error('ASYMP_DTF requires six input arguments.')
end
[m,n] = size(u);
if m > n
   u = u.';
end
np = length(u);
[nChannels,~,p] = size(A);
Af = A_to_f(A, nFreqs);

flgVerbose = 0;

% Variables pre-alocation
dtf  = zeros(nChannels,nChannels,nFreqs); % dtf will hold complex DTF estimates
dtf2 = zeros(nChannels,nChannels,nFreqs);

if alpha ~= 0
   th  = zeros(nChannels,nChannels,nFreqs);
   ci1 = zeros(nChannels,nChannels,nFreqs);
   ci2 = zeros(nChannels,nChannels,nFreqs);
   varass1 = zeros(nChannels,nChannels,nFreqs);
   varass2 = zeros(nChannels,nChannels,nFreqs);
   patdfr = zeros(nChannels,nChannels,nFreqs);
   patdenr = zeros(nChannels,nChannels,nFreqs);
   pvalues = zeros(nChannels,nChannels,nFreqs);
   
   if flgVerbose
      switch lower(metric)
         case {'euc'}
            disp('* Original DTF and asymptotic statistics')
         case {'diag'}
            disp('* Generalized DTF or DC and asymptotic statistics')
         case {'info'}
            disp('* Information DTF and asymptotic statistics')
         otherwise
            error('Unknown metric.')
      end
   end
elseif flgVerbose
   switch lower(metric)
      case {'euc'}
         disp('* Original DTF estimation')
      case {'diag'}
         disp('* Generalized DTF/DC estimation')
      case {'info'}
         disp('* Information DTF estimation')
      otherwise
         error('Unknown metric.')
   end
end

switch lower(metric)
   case {'euc'}               % for DTF
      ddtf_dev = zeros(1,nChannels^2);
      pfe  = eye(nChannels);  % for complex DTF calculation  
      
   case {'diag'}              % for DC
      evar_d = mdiag(pf);
      evar_d_big = kron(eye(2),kron(evar_d,eye(nChannels)));

      debig_de = fdebig_de_dtf(nChannels); %New Theta_K
      dedinv_deh = debig_de*diag(vec(eye(nChannels)));
      pfe = pf;                % for complex DC calculation

   case {'info'}               % for iDTF
      evar_d = mdiag(pf);
      evar_d_big = kron(eye(2),kron(evar_d,eye(nChannels)));
      evar_big = kron(eye(2),kron(pf,eye(nChannels)));

      debig_de = fdebig_de_dtf(nChannels); %New Theta_K
      dedinv_deh = debig_de*diag(vec(eye(nChannels)));
      pfe = pf;                % for complex iDTF calculation

   otherwise
      error('Unknown metric.')
end

gamma = bigautocorr(u, p);
omega = kron(pinv(gamma), pf);
omega_evar = 2*Dup(nChannels)*pinv(Dup(nChannels))*kron(pf, pf) ...
                            *(pinv(Dup(nChannels)).')*Dup(nChannels).';

icdf_norm_alpha = norminv(1 - alpha/2.0,0,1);

for ff = 1:nFreqs
   f = (ff - 1)/(2*nFreqs); % Corrected 7/25/2011, f starts at 0.
   Ca = fCa(f, p, nChannels);

   Af_ff = reshape(Af(ff,:,:),[nChannels, nChannels]);
   Hf = pinv(Af_ff); h = Hf(:);  % Equivalent to h = vec(Af[ff, :, :].I)

   h = [real(h); imag(h)];    % h = cat(h.real, h.imag, 0)
   H = fdh_da(Af_ff);         % = ha; H = fdh_da(mat(Af[ff, :, :]), n)

   Omega_h = H*Ca*omega*Ca.'*H.';  % \Omega_h
   L = fChol(Omega_h); % real-part only

   for i = 1:nChannels
      Ii = fIi(i,nChannels);

      switch lower(metric)
         case {'euc'}           % for DTF
            Iie  = Ii;
         case {'diag'}          % for DC
            Iie  = Ii*evar_d_big*Ii;
         case {'info'}          % for iDTF
            Iie  = Ii*evar_big;            
         otherwise
            error('Unknown metric.')
      end

      for j = 1:nChannels
         Iij = fIij(i,j,nChannels);

         switch lower(metric)
            case {'euc'}               % for DTF
               Iije = Iij;

            case {'diag'}              % for DC
               Iije = Iij*evar_d_big*Iij;

            case {'info'}              % for iDTF
               Iije = Iij*evar_d_big;

            otherwise
               error('Unknown metric.')
         end

         num = h.'*Iije*h;
         den = h.'*Iie*h;
         
         dtf2(i,j,ff) = num/den; % |DTF_{ij}(ff)|^2 squared-|DTF|
         dtf(i,j,ff)  = Hf(i,j)*sqrt(pfe(j,j))/sqrt(den); % complex-DTF
         
         % If alpha == 0, do not calculate statistics for faster DTF computation.
         if alpha ~= 0
            %'Add evar differentiation'
            switch lower(metric)
               case {'euc'}               % for DTF
                  %nop

               case {'diag'}              % for DC
                  dnum_dev = kron((Iij*h).', h.'*Iij)*dedinv_deh;
                  %'derivative of den by vecE'
                  dden_dev = kron((Ii*h).', h.'*Ii)*dedinv_deh;
                  ddtf_dev = (den*dnum_dev - num*dden_dev)/(den^2);
                  
               case {'info'}              % for iDTF
                  %'derivative of num by vecE'
                  dnum_dev = kron((Iij*h).', h.'*Iij) * dedinv_deh;
                  %'derivative of den by vecE'
                  dden_dev = kron((Ii*h).', h.'*Ii) * debig_de;
                  ddtf_dev = (den*dnum_dev - num*dden_dev)/(den^2);
                  
               otherwise
                  error('Unknown metric.')
            end

            G1h = 2*h.'*Iije/den - 2*num*h.'*Iie/(den^2); % Eq. (15)
            %   G1 = -G1h*H*Ca;                           % (Cont.)
            varalpha = G1h*Omega_h*G1h.';
            varevar = ddtf_dev*omega_evar*ddtf_dev.';
            varass1(i,j,ff) = (varalpha + varevar)/np;    % Eq. (14)

            ci1(i,j,ff) = dtf2(i,j,ff) ...
                          - sqrt(varass1(i,j,ff))*icdf_norm_alpha;
            ci2(i,j,ff) = dtf2(i,j,ff) ...
                          + sqrt(varass1(i,j,ff))*icdf_norm_alpha;

            G2h = Iije/den;
            d = fEig(real(L), real(G2h)); % real() 28May2013

            patdf = (sum(d).^2)./sum(d.^2);
            patden = sum(d)./sum(d.^2);

             th(i,j,ff) = chi2inv((1 - alpha), patdf)/(patden*np); % original KS 
%            th(i,j,ff) = chi2inv((1 - alpha), patdf)./(np);
            pvalues(i,j,ff) = 1 - chi2cdf(dtf2(i,j,ff)*patden*np, patdf);

            varass2(i,j,ff) = patdf/(patden*np).^2;
            patdfr(i,j,ff) = patdf;
            patdenr(i,j,ff) = patden;
            
         else % as alpha == 0, do not compute asymptotics
            %nop
         end
      end
   end
end

if alpha ~= 0
   c.dtf = dtf;   % Complex DTF2/DC2/iDTF2
   c.dtf2 = dtf2;
   c.th = th;
   c.ci1 = ci1;  % Lower CI
   c.ci2 = ci2;  % Upper CI
   c.metric = metric;
   c.alpha = alpha;
   c.p = p;
   c.pvalues = pvalues; % p-values associated to DTF2/DC2/iDTF2
   c.patden = patdenr;
   c.patdf = patdfr;
   c.varass1 = varass1;
   c.varass2 = varass2;
   
   % Statistically significant DTF2 on frequency scale
   dtf2_temp = ((abs(dtf2) - abs(th)) > 0).*dtf2 ...
                                           + ((abs(dtf2) - abs(th)) <= 0)*(-1);
   dtf2_temp(dtf2_temp < 0) = NaN; % Octave
   c.dtf2_th = dtf2_temp;
   
else
    c.dtf = dtf;
    c.dtf2 = dtf2;
    c.metric = metric;
    c.alpha = 0;
    c.p = p;
    c.th = [];
    c.ci1 = [];
    c.ci2 = [];
    c.pvalues = [];
    c.patden = [];
    c.patdf = [];
    c.varass1 = [];
    c.varass2 = [];
end

% Power spectra and coherence calculation
c.SS = ss_alg(A, pf, nFreqs);
c.coh2 = coh_alg(c.SS);


%==========================================================================
function gamma = bigautocorr(x, p)
%Autocorrelation. Data in rows. From order 0 to p-1.
%Output: n x n blocks of autocorr of lags i. (Nuttall Strand matrix)'''
[n, nd] = size(x);

gamma = zeros(n*p, n*p);
for i = 1:p
   for j = 1:p
      gamma(((i - 1)*n + 1):i*n, ((j - 1)*n + 1):j*n) = ...
                                       xlag(x, i - 1)*(xlag(x,j - 1).')/nd;
   end
end

%==========================================================================
function c = xlag(x,tlag)
if tlag == 0
   c = x;
else
   c = zeros(size(x));
   c(:,(tlag + 1):end) = x(:,1:(end - tlag));
end

%==========================================================================
function d = fEig(L, G2)
%'''Returns the eigenvalues'''

%L = mat(cholesky(omega, lower=1))
D = L.'*G2*L;
%    d = eigh(D, eigvals_only=True)
%disp('fEig: eig or svd?')
d = svd(D);
d1 = sort(d);
%
% the two biggest eigenvalues no matter which values (non negative by
% construction
%
d = d1(length(d) - 1:length(d));

if (size(d) > 2)
   disp('More than two Chi-squares in the sum:')
end

%==========================================================================
function c = fIij(i,j,n)
%'''Returns Iij of the formula'''
Iij = zeros(1,n^2);
Iij(n*(j - 1) + i) = 1;
Iij = diag(Iij);
c = kron(eye(2), Iij);

%==========================================================================
% function c = fIj(j,n)
% %'''Returns Ij of the formula'''
% Ij = zeros(1,n);
% Ij(j) = 1;
% Ij = diag(Ij);
% Ij = kron(Ij,eye(n));
% c = kron(eye(2), Ij);

%==========================================================================
function c = fIi(i,n)
%    '''Returns Ii of the formula'''
Ii = zeros(1,n);
Ii(i) = 1;
Ii = diag(Ii);
Ii = kron(eye(n), Ii);
c = kron(eye(2), Ii);

%==========================================================================
function d = fCa(f, p, n)
%'''Returns C* of the formula'''
C1 = cos(-2*pi*f*(1:p));
S1 = sin(-2*pi*f*(1:p));
C2 = [C1; S1];
d = kron(C2, eye(n^2));

%==========================================================================
% function c = fdebig_de(n)
% %'''Derivative of kron(I(2n), A) by A'''
% %c = kron(TT(2*n, n), eye(n*2*n)) * kron(eye(n), kron(vec(eye(2*n)), eye(n)));
% A=sparse(kron(TT(2*n, n), eye(n*2*n)));
% B=sparse(kron(vec(eye(2*n)), eye(n)));
% c = A * kron(eye(n), B);
% c=sparse(c);

%==========================================================================
function c = fdebig_de_dtf(n)
%''' New \Theta_K for DTF asymptotics'''
%c = kron(kron(eye(2*n),TT(n, 2*n)), eye(n)));
%A=sparse(kron(eye(2*n), TT(n, 2*n)));
%c=sparse(kron(A, eye(n)));
A=sparse(kron(TT(n^2,2),eye(n^2)));
A1=sparse(kron(eye(2),A));
A=sparse(kron(TT(n^2,1),eye(n)));
%A=sparse(kron(TT(1,n^2),eye(n)));
A2=sparse(kron(eye(n),A));
A3=sparse(kron(eye(n^2),vec(eye(n))));
A4=sparse(A2*A3);
A5=sparse(kron(vec(eye(2)),A4));
c=sparse(A1*A5);
% To generate sparse matrix
%c=sparse(c*diag(vec(eye(n))));

%==========================================================================
function c = vec(x)
%vec = lambda x: mat(x.ravel('F')).T
c=x(:);

%==========================================================================
function t = TT(a,b)
%''' TT(a,b)*vec(B) = vec(B.T), where B is (a x b).'''
t = zeros(a*b);
for i = 1:a
   for j =1:b
      t((i - 1)*b + j,(j - 1)*a + i) = 1;
   end
end
t = sparse(t);

%==========================================================================
function L = fChol(omega)
% Try Cholesky factorization
try
   L = chol(omega)';
   % If there's a small negative eigenvalue, diagonalize
catch % err
   %   disp('linalgerror, probably IP = 1.')
   [v,d] = eig(omega);
   L = zeros(size(v));
   for i =1:length(d)
      if d(i,i)<0
         d(i,i)=eps;
      end
      L(:,i) = v(:,i)*sqrt(d(i,i));
   end
end

%==========================================================================
function c = mdiag(a)
%  diagonal matrix
c = diag(diag(a));

%==========================================================================
function d = Dup(n)
%     '''D*vech(A) = vec(A), with symmetric A'''
d = zeros(n*n, (n*(n + 1))/2);
count = 1;
for j= 1:n
   for i = 1:n
      if i >= j
         d((j - 1)*n + i,count)=1;
         count = count + 1;
      else
         d((j - 1)*n + i,:)=d((i - 1)*n + j,:);
      end
   end
end

%==========================================================================
function hh=fdh_da(Af)
%    '''Derivative of vec(H) by vec(A), with $H = A^{-1}$ and complex A.'''
ha = pinv(Af);
h = -kron(ha.', ha);

h1 = [real(h) -imag(h)];
h2 = [imag(h) real(h)];   %h2 = cat(h.imag, h.real, 1)
hh = -[h1; h2];           %hh = cat(h1, h2, 0)

%==========================================================================

%%
%        1         2         3         4         5         6         7         8         9
%23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
%% Change Log:
% [2011/07/25]: The asymp_pdc routine, which asymp_dtf is derived from, was corrected on
%              to match the frequency range with plotting routine, f = 0 was
%              included in the "frequency" for-loop:
%                                for ff = 1:nFreqs,
%                                   f = (ff-1)/(2*nFreqs); %
%                                        ^?^^
% [2021/09/02, LAB]: complex dtf calculation added
%
% [2015/01/07]: Optimization \(^o^)/

% [EOF]

##### SOURCE END #####
--></body></html>